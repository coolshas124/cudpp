<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>CUDPP: A Simple CUDPP Example</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CUDPP&#160;<span id="projectnumber">2.0</span></div>
   <div id="projectbrief">CUDA Data-Parallel Primitives Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">A Simple CUDPP Example </div>  </div>
</div>
<div class="contents">
<div class="textblock"><p>This code sample demonstrates a basic usage of CUDPP for computing the parallel prefix sum of a floating point array on the GPU.</p>
<h2><a class="anchor" id="codeWalkthrough"></a>
Sample Code Walkthrough</h2>
<p>The simpleCUDPP sample is the "hello" world example for CUDPP. Its aim is to show you how to initialize, run, and shut down CUDPP functions.</p>
<p>The main function in simpleCUDPP.cu is <code>runTest()</code>.</p>
<h3><a class="anchor" id="runTest"></a>
runTest()</h3>
<p><code>runTest</code> starts by initializing the CUDA device and then declaring the number of elements and the array size for the arrays we plan to scan. It then allocates the host-side (CPU-side) input array, <code>h_idata</code>, and initializes the data it contains with some random values between 0 and 15.</p>
<p><div class="fragment"><pre class="fragment"><span class="keywordtype">void</span>
runTest( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) 
{
    <span class="keywordtype">int</span> deviceCount;
    cudaGetDeviceCount(&amp;deviceCount);
    <span class="keywordflow">if</span> (deviceCount == 0) {
        fprintf(stderr, <span class="stringliteral">&quot;error: no devices supporting CUDA.\n&quot;</span>);
        exit(EXIT_FAILURE);
    }
    <span class="keywordtype">int</span> dev = 0;
    <span class="keywordflow">if</span> (argc &gt; 1) {
        std::string arg = argv[1];
        <span class="keywordtype">size_t</span> pos = arg.find(<span class="stringliteral">&quot;=&quot;</span>);
        <span class="keywordflow">if</span> (arg.find(<span class="stringliteral">&quot;device&quot;</span>) &amp;&amp; pos != std::string::npos) {
            dev = atoi(arg.c_str() + (pos + 1));
        }
    }
    <span class="keywordflow">if</span> (dev &lt; 0) dev = 0;
    <span class="keywordflow">if</span> (dev &gt; deviceCount-1) dev = deviceCount - 1;
    cudaSetDevice(dev);

    cudaDeviceProp prop;
    <span class="keywordflow">if</span> (cudaGetDeviceProperties(&amp;prop, dev) == cudaSuccess)
    {
        printf(<span class="stringliteral">&quot;Using device %d:\n&quot;</span>, dev);
        printf(<span class="stringliteral">&quot;%s; global mem: %dB; compute v%d.%d; clock: %d kHz\n&quot;</span>,
               prop.name, (<span class="keywordtype">int</span>)prop.totalGlobalMem, (<span class="keywordtype">int</span>)prop.major, 
               (<span class="keywordtype">int</span>)prop.minor, (<span class="keywordtype">int</span>)prop.clockRate);
    }
</pre></div></p>
<p>After the input data is created on the host, we allocate a device (GPU) array <code>d_idata</code> and copy the input data from the host using <code>cudaMemcpy()</code>. We also allocate a device array for the output results, <code>d_odata</code>.</p>
<p><div class="fragment"><pre class="fragment">
    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numElements = 32768;
    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> memSize = <span class="keyword">sizeof</span>( float) * numElements;

    <span class="comment">// allocate host memory</span>
    <span class="keywordtype">float</span>* h_idata = (<span class="keywordtype">float</span>*) malloc( memSize);
    <span class="comment">// initalize the memory</span>
    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; numElements; ++i) 
    {
        h_idata[i] = (float) (rand() &amp; 0xf);
    }

    <span class="comment">// allocate device memory</span>
    <span class="keywordtype">float</span>* d_idata;
    cudaError_t result = cudaMalloc( (<span class="keywordtype">void</span>**) &amp;d_idata, memSize);
    <span class="keywordflow">if</span> (result != cudaSuccess) {
        printf(<span class="stringliteral">&quot;Error: %s\n&quot;</span>, cudaGetErrorString(result));
        exit(-1);
    }
    
    <span class="comment">// copy host memory to device</span>
    result = cudaMemcpy( d_idata, h_idata, memSize, cudaMemcpyHostToDevice);
    <span class="keywordflow">if</span> (result != cudaSuccess) {
        printf(<span class="stringliteral">&quot;Error: %s\n&quot;</span>, cudaGetErrorString(result));
        exit(-1);
    }
     
    <span class="comment">// allocate device memory for result</span>
    <span class="keywordtype">float</span>* d_odata;
    result = cudaMalloc( (<span class="keywordtype">void</span>**) &amp;d_odata, memSize);
    <span class="keywordflow">if</span> (result != cudaSuccess) {
        printf(<span class="stringliteral">&quot;Error: %s\n&quot;</span>, cudaGetErrorString(result));
        exit(-1);
    }
</pre></div></p>
<h3><a class="anchor" id="initialization"></a>
CUDPP Initialization</h3>
<p>Before we use the CUDPP library, we must initialize it. We do this by calling <a class="el" href="group__public_interface.html#ga9156a26943f99d0fff44d218129631b4" title="Creates an instance of the CUDPP library, and returns a handle.">cudppCreate()</a>, which returns a handle to the CUDPP library object. This handle must be used when creating CUDPP plans (described next), so it must be held by the calling thread until it is ready to shut down CUDPP.</p>
<p><div class="fragment"><pre class="fragment">
    <span class="comment">// Initialize the CUDPP Library</span>
    CUDPPHandle theCudpp;
    <a class="code" href="group__public_interface.html#ga9156a26943f99d0fff44d218129631b4" title="Creates an instance of the CUDPP library, and returns a handle.">cudppCreate</a>(&amp;theCudpp);
</pre></div></p>
<h3><a class="anchor" id="plans"></a>
CUDPP Plans</h3>
<p>Next comes the real CUDPP stuff. First we have to configure CUDPP to scan our array. Configuration of algorithms in CUDPP relies on the concept of the <em>plan</em>. A plan is a data structure that maintains intermediate storage for the algorithm, as well as information that CUDPP may use to optimize execution of the present hardware. When invoked using <a class="el" href="group__public_interface.html#ga31fd56135f9c8f73da79af83a958f27c" title="Create a CUDPP plan.">cudppPlan()</a>, the CUDPP planner takes the configuration details passed to it and generates an internal plan object. It returns a CUDPPHandle -- an opaque pointer type that is used to refer to the plan object -- that must be passed to other CUDPP functions in order to execute algorithms.</p>
<p>In this case we are going to do a forward exclusive <code>float</code> sum-scan of <code>numElements</code> elements. We tell the planner this by filling out a <a class="el" href="struct_c_u_d_p_p_configuration.html" title="Configuration struct used to specify algorithm, datatype, operator, and options when creating a plan ...">CUDPPConfiguration</a> struct with the algorithm (CUDPP_SCAN), datatype (CUDPP_FLOAT), operation (CUDPP_ADD), and options (CUDPP_OPTION_FORWARD, CUDPP_OPTION_EXCLUSIVE). We then pass this <em>config</em> to cudppPlan along with the maximum number of elements we want to scan, <em>numElements</em>. Finally, we pass 1 and 0 for the <em>numRows</em> and <em>rowPitch</em> parameters, since we only want to scan a one-dimensional array. See the documentation for <a class="el" href="group__public_interface.html#ga31fd56135f9c8f73da79af83a958f27c" title="Create a CUDPP plan.">cudppPlan()</a> for more details on these parameters.</p>
<p><div class="fragment"><pre class="fragment">
    <a class="code" href="struct_c_u_d_p_p_configuration.html" title="Configuration struct used to specify algorithm, datatype, operator, and options when creating a plan ...">CUDPPConfiguration</a> config;
    config.<a class="code" href="struct_c_u_d_p_p_configuration.html#a78a6e0a90e97b79be8850ae3dff7819e" title="The numerical operator to be applied.">op</a> = <a class="code" href="cudpp_8h.html#afbc449e0243beebf799175ba0633a386a2464c1df67b312f9b1461e0214ed5ade" title="Addition of two operands.">CUDPP_ADD</a>;
    config.<a class="code" href="struct_c_u_d_p_p_configuration.html#a8127968c4b5c05d22956e2baa41a664d" title="The datatype of the input arrays.">datatype</a> = <a class="code" href="cudpp_8h.html#a8d0edad02eb8303164acb8f4abca612dafe9aa2a2ea7725eb0ea758a8dbc54399" title="Float type (C float)">CUDPP_FLOAT</a>;
    config.<a class="code" href="struct_c_u_d_p_p_configuration.html#a2d11e99b0c4a2b919c0bdb1c5001acfe" title="The algorithm to be used.">algorithm</a> = <a class="code" href="cudpp_8h.html#a6499e5c26f56db82f520367ae853462fa82cf703e248569c24544c3792048e06f" title="Scan or prefix-sum.">CUDPP_SCAN</a>;
    config.<a class="code" href="struct_c_u_d_p_p_configuration.html#a32140ada5ca87b081d1cd42d29a18c11" title="Options to configure the algorithm.">options</a> = <a class="code" href="cudpp_8h.html#afdaa492f807dd46b6b529a7f962d3576af3195c0a67325a796954c781372c7e13">CUDPP_OPTION_FORWARD</a> | <a class="code" href="cudpp_8h.html#afdaa492f807dd46b6b529a7f962d3576a65c9029495c4bda89f73435c221cc46b">CUDPP_OPTION_EXCLUSIVE</a>;
    
    CUDPPHandle scanplan = 0;
    <a class="code" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a" title="CUDPP Result codes returned by CUDPP API functions.">CUDPPResult</a> res = <a class="code" href="group__public_interface.html#ga31fd56135f9c8f73da79af83a958f27c" title="Create a CUDPP plan.">cudppPlan</a>(theCudpp, &amp;scanplan, config, numElements, 1, 0);  

    <span class="keywordflow">if</span> (<a class="code" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0aa593cd6a69fc69e6a186a2d53d4e13dbd">CUDPP_SUCCESS</a> != res)
    {
        printf(<span class="stringliteral">&quot;Error creating CUDPPPlan\n&quot;</span>);
        exit(-1);
    }
</pre></div></p>
<p>We now have a handle to our plan object in <em>scanplan</em>. Next, after making sure that <a class="el" href="group__public_interface.html#ga31fd56135f9c8f73da79af83a958f27c" title="Create a CUDPP plan.">cudppPlan()</a> did not return an error, we put CUDPP to work by invoking <a class="el" href="group__public_interface.html#ga19f4711b5219ff1fd4851fda0398d547" title="Performs a scan operation of numElements on its input in GPU memory (d_in) and places the output in G...">cudppScan()</a>, to which we pass our plan handle, the output and input device arrays, and the number of elements to scan.</p>
<p><div class="fragment"><pre class="fragment">    <span class="comment">// Run the scan</span>
    res = <a class="code" href="group__public_interface.html#ga19f4711b5219ff1fd4851fda0398d547" title="Performs a scan operation of numElements on its input in GPU memory (d_in) and places the output in G...">cudppScan</a>(scanplan, d_odata, d_idata, numElements);
    <span class="keywordflow">if</span> (<a class="code" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0aa593cd6a69fc69e6a186a2d53d4e13dbd">CUDPP_SUCCESS</a> != res)
    {
        printf(<span class="stringliteral">&quot;Error in cudppScan()\n&quot;</span>);
        exit(-1);
    }
</pre></div></p>
<p>Next, we read the results of the scan from d_odata back to the host, compute a reference solution on the CPU (<code>computeSumScanGold()</code>), and compare the results for correctness.</p>
<p><div class="fragment"><pre class="fragment">
    <span class="comment">// allocate mem for the result on host side</span>
    <span class="keywordtype">float</span>* h_odata = (<span class="keywordtype">float</span>*) malloc( memSize);
    <span class="comment">// copy result from device to host</span>
    result = cudaMemcpy( h_odata, d_odata, memSize, cudaMemcpyDeviceToHost);
    <span class="keywordflow">if</span> (result != cudaSuccess) {
        printf(<span class="stringliteral">&quot;Error: %s\n&quot;</span>, cudaGetErrorString(result));
        exit(-1);
    }
</pre></div></p>
<p>Finally, we tell CUDPP to clean up the memory used for our plan object, using <a class="el" href="group__public_interface.html#ga4015898886e140ad95f320ab4c07db2c" title="Destroy a CUDPP Plan.">cudppDestroyPlan()</a>. Then we shut down the CUDPP library using <a class="el" href="group__public_interface.html#ga8b98b05d585860ec4fcc44472244d01b" title="Destroys an instance of the CUDPP library given its handle.">cudppDestroy()</a>, passing it the handle we received from <a class="el" href="group__public_interface.html#ga9156a26943f99d0fff44d218129631b4" title="Creates an instance of the CUDPP library, and returns a handle.">cudppCreate()</a>. Finally we free the host and device arrays using <code>free()</code> and <code>cudaFree</code>, respectively.</p>
<p><div class="fragment"><pre class="fragment">    
    <span class="comment">// compute reference solution</span>
    <span class="keywordtype">float</span>* reference = (<span class="keywordtype">float</span>*) malloc( memSize);
    computeSumScanGold( reference, h_idata, numElements, config);

    <span class="comment">// check result</span>
    <span class="keywordtype">bool</span> passed = <span class="keyword">true</span>;
    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; numElements; i++)
        <span class="keywordflow">if</span> (reference[i] != h_odata[i]) passed = <span class="keyword">false</span>;
        
    printf( <span class="stringliteral">&quot;Test %s\n&quot;</span>, passed ? <span class="stringliteral">&quot;PASSED&quot;</span> : <span class="stringliteral">&quot;FAILED&quot;</span>);

    res = <a class="code" href="group__public_interface.html#ga4015898886e140ad95f320ab4c07db2c" title="Destroy a CUDPP Plan.">cudppDestroyPlan</a>(scanplan);
    <span class="keywordflow">if</span> (<a class="code" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0aa593cd6a69fc69e6a186a2d53d4e13dbd">CUDPP_SUCCESS</a> != res)
    {
        printf(<span class="stringliteral">&quot;Error destroying CUDPPPlan\n&quot;</span>);
        exit(-1);
    }

    <span class="comment">// shut down the CUDPP library</span>
    <a class="code" href="group__public_interface.html#ga8b98b05d585860ec4fcc44472244d01b" title="Destroys an instance of the CUDPP library given its handle.">cudppDestroy</a>(theCudpp);
    
    free( h_idata);
    free( h_odata);
    free( reference);
    cudaFree(d_idata);
    cudaFree(d_odata);
}
</pre></div></p>
<p>Using CUDPP for parallel prefix sums is easy! </p>
</div></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Tue Aug 9 2011 11:59:20 for CUDPP by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
