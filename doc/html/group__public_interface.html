<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>CUDPP: CUDPP Public Interface</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CUDPP&#160;<span id="projectnumber">2.0</span></div>
   <div id="projectbrief">CUDA Data-Parallel Primitives Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">CUDPP Public Interface</div>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="member-group"></a>
Algorithm Interface</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#ga19f4711b5219ff1fd4851fda0398d547">cudppScan</a> (const CUDPPHandle planHandle, void *d_out, const void *d_in, size_t numElements)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a scan operation of numElements on its input in GPU memory (d_in) and places the output in GPU memory (d_out), with the scan parameters specified in the plan pointed to by planHandle.  <a href="#ga19f4711b5219ff1fd4851fda0398d547"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#gaf71eb423ec3252ca122e5c01b055fa51">cudppSegmentedScan</a> (const CUDPPHandle planHandle, void *d_out, const void *d_idata, const unsigned int *d_iflags, size_t numElements)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a segmented scan operation of numElements on its input in GPU memory (d_idata) and places the output in GPU memory (d_out), with the scan parameters specified in the plan pointed to by planHandle.  <a href="#gaf71eb423ec3252ca122e5c01b055fa51"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#gad9655b51dba16bc43b8adee4507dc1d0">cudppMultiScan</a> (const CUDPPHandle planHandle, void *d_out, const void *d_in, size_t numElements, size_t numRows)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs numRows parallel scan operations of numElements each on its input (d_in) and places the output in d_out, with the scan parameters set by config. Exactly like cudppScan except that it runs on multiple rows in parallel.  <a href="#gad9655b51dba16bc43b8adee4507dc1d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#gab3fd0152a8e5b1860b1b7b09a3753ae0">cudppCompact</a> (const CUDPPHandle planHandle, void *d_out, size_t *d_numValidElements, const void *d_in, const unsigned int *d_isValid, size_t numElements)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an array <em>d_in</em> and an array of 1/0 flags in <em>deviceValid</em>, returns a compacted array in <em>d_out</em> of corresponding only the "valid" values from <em>d_in</em>.  <a href="#gab3fd0152a8e5b1860b1b7b09a3753ae0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#ga21d9b2b3c74daffbec52ef628f835313">cudppReduce</a> (const CUDPPHandle planHandle, void *d_out, const void *d_in, size_t numElements)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduces an array to a single element using a binary associative operator.  <a href="#ga21d9b2b3c74daffbec52ef628f835313"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#ga234f3b894d9cc5a04bb48d886773a0f0">cudppSort</a> (const CUDPPHandle planHandle, void *d_keys, void *d_values, size_t numElements)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts key-value pairs or keys only.  <a href="#ga234f3b894d9cc5a04bb48d886773a0f0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#gaeedaa3a7ec8bbd6770c6fbce3c4276c5">cudppSparseMatrixVectorMultiply</a> (const CUDPPHandle sparseMatrixHandle, void *d_y, const void *d_x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform matrix-vector multiply y = A*x for arbitrary sparse matrix A and vector x.  <a href="#gaeedaa3a7ec8bbd6770c6fbce3c4276c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#gac27c987891faceedf79598f744212c67">cudppRand</a> (const CUDPPHandle planHandle, void *d_out, size_t numElements)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Rand puts <em>numElements</em> random 32-bit elements into <em>d_out</em>.  <a href="#gac27c987891faceedf79598f744212c67"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#ga9120af9942d2553d2f376ede0f7079dd">cudppRandSeed</a> (const CUDPPHandle planHandle, unsigned int seed)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the seed used for rand.  <a href="#ga9120af9942d2553d2f376ede0f7079dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#gabd3c1f97e1d22839756fd2594aaefb56">cudppTridiagonal</a> (CUDPPHandle planHandle, void *d_a, void *d_b, void *d_c, void *d_d, void *d_x, int systemSize, int numSystems)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves tridiagonal linear systems.  <a href="#gabd3c1f97e1d22839756fd2594aaefb56"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Library Management Interface</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#ga9156a26943f99d0fff44d218129631b4">cudppCreate</a> (CUDPPHandle *theCudpp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of the CUDPP library, and returns a handle.  <a href="#ga9156a26943f99d0fff44d218129631b4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#ga8b98b05d585860ec4fcc44472244d01b">cudppDestroy</a> (CUDPPHandle theCudpp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys an instance of the CUDPP library given its handle.  <a href="#ga8b98b05d585860ec4fcc44472244d01b"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Plan Interface</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#ga31fd56135f9c8f73da79af83a958f27c">cudppPlan</a> (const CUDPPHandle cudppHandle, CUDPPHandle *planHandle, <a class="el" href="struct_c_u_d_p_p_configuration.html">CUDPPConfiguration</a> config, size_t numElements, size_t numRows, size_t rowPitch)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a CUDPP plan.  <a href="#ga31fd56135f9c8f73da79af83a958f27c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#ga4015898886e140ad95f320ab4c07db2c">cudppDestroyPlan</a> (CUDPPHandle planHandle)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a CUDPP Plan.  <a href="#ga4015898886e140ad95f320ab4c07db2c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#gabc6c2587fe06dadd93fb1d69ba836d84">cudppSparseMatrix</a> (const CUDPPHandle cudppHandle, CUDPPHandle *sparseMatrixHandle, <a class="el" href="struct_c_u_d_p_p_configuration.html">CUDPPConfiguration</a> config, size_t numNonZeroElements, size_t numRows, const void *A, const unsigned int *h_rowIndices, const unsigned int *h_indices)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a CUDPP Sparse Matrix Object.  <a href="#gabc6c2587fe06dadd93fb1d69ba836d84"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#gae0644c758120abaef0e2bb396f57cefb">cudppDestroySparseMatrix</a> (CUDPPHandle sparseMatrixHandle)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a CUDPP Sparse Matrix Object.  <a href="#gae0644c758120abaef0e2bb396f57cefb"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Hash Table Interface</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga735902f6999db2580e1b17912cbd3eae"></a><!-- doxytag: member="publicInterface::CUDPP_HASH_KEY_NOT_FOUND" ref="ga735902f6999db2580e1b17912cbd3eae" args="" -->
const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>CUDPP_HASH_KEY_NOT_FOUND</b> = CudaHT::CuckooHashing::kNotFound</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#ga0cd993f24223a9e5b59fc84bff5be22b">cudppHashTable</a> (CUDPPHandle cudppHandle, CUDPPHandle *plan, const <a class="el" href="struct_c_u_d_p_p_hash_table_config.html">CUDPPHashTableConfig</a> *config)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a CUDPP hash table in GPU memory given an input hash table configuration; returns the <em>plan</em> for that hash table.  <a href="#ga0cd993f24223a9e5b59fc84bff5be22b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#gaa93793870394fdb90859d6f1e0ff662b">cudppHashInsert</a> (CUDPPHandle plan, const void *d_keys, const void *d_vals, size_t num)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts keys and values into a CUDPP hash table.  <a href="#gaa93793870394fdb90859d6f1e0ff662b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#ga8a351e4f3c9d69e3111c3463784e7ebe">cudppHashRetrieve</a> (CUDPPHandle plan, const void *d_keys, void *d_vals, size_t num)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves values, given keys, from a CUDPP hash table.  <a href="#ga8a351e4f3c9d69e3111c3463784e7ebe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#gac78326e26664036e8526de8f7a662c0f">cudppDestroyHashTable</a> (CUDPPHandle cudppHandle, CUDPPHandle plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a hash table given its handle.  <a href="#gac78326e26664036e8526de8f7a662c0f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#gaab1189a6b1ce8ebb63c02ef46acd9595">cudppMultivalueHashGetValuesSize</a> (CUDPPHandle plan, unsigned int *size)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the size of the values array in a multivalue hash table.  <a href="#gaab1189a6b1ce8ebb63c02ef46acd9595"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#ga6b5e657c472ed38442fe45861836bc9d">cudppMultivalueHashGetAllValues</a> (CUDPPHandle plan, unsigned int **d_vals)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a pointer to the values array in a multivalue hash table.  <a href="#ga6b5e657c472ed38442fe45861836bc9d"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>The CUDA public interface comprises the functions, structs, and enums defined in <a class="el" href="cudpp_8h.html" title="Main library header file. Defines public interface.">cudpp.h</a>. Public interface functions call functions in the <a class="el" href="group__cudpp__app.html">Application-Level</a> interface. The public interface functions include Plan Interface functions and Algorithm Interface functions. Plan Interface functions are used for creating CUDPP Plan objects that contain configuration details, intermediate storage space, and in the case of <a class="el" href="group__public_interface.html#gabc6c2587fe06dadd93fb1d69ba836d84" title="Create a CUDPP Sparse Matrix Object.">cudppSparseMatrix()</a>, data. The Algorithm Interface is the set of functions that do the real work of CUDPP, such as <a class="el" href="group__public_interface.html#ga19f4711b5219ff1fd4851fda0398d547" title="Performs a scan operation of numElements on its input in GPU memory (d_in) and places the output in G...">cudppScan()</a> and <a class="el" href="group__public_interface.html#gaeedaa3a7ec8bbd6770c6fbce3c4276c5" title="Perform matrix-vector multiply y = A*x for arbitrary sparse matrix A and vector x.">cudppSparseMatrixVectorMultiply()</a>. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga19f4711b5219ff1fd4851fda0398d547"></a><!-- doxytag: member="cudpp.cpp::cudppScan" ref="ga19f4711b5219ff1fd4851fda0398d547" args="(const CUDPPHandle planHandle, void *d_out, const void *d_in, size_t numElements)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppScan </td>
          <td>(</td>
          <td class="paramtype">const CUDPPHandle&#160;</td>
          <td class="paramname"><em>planHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>d_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs a scan operation of numElements on its input in GPU memory (d_in) and places the output in GPU memory (d_out), with the scan parameters specified in the plan pointed to by planHandle. </p>
<p>The input to a scan operation is an input array, a binary associative operator (like + or max), and an identity element for that operator (+'s identity is 0). The output of scan is the same size as its input. Informally, the output at each element is the result of operator applied to each input that comes before it. For instance, the output of sum-scan at each element is the sum of all the input elements before that input.</p>
<p>More formally, for associative operator  &oplus; , <em>out<sub>i</sub></em> = <em>in<sub>0</sub></em>  &oplus;  <em>in<sub>1</sub></em>  &oplus;  ...  &oplus;  <em>in<sub>i-1</sub></em>.</p>
<p>CUDPP supports "exclusive" and "inclusive" scans. For the ADD operator, an exclusive scan computes the sum of all input elements before the current element, while an inclusive scan computes the sum of all input elements up to and including the current element.</p>
<p>Before calling scan, create an internal plan using <a class="el" href="group__public_interface.html#ga31fd56135f9c8f73da79af83a958f27c" title="Create a CUDPP plan.">cudppPlan()</a>.</p>
<p>After you are finished with the scan plan, clean up with <a class="el" href="group__public_interface.html#ga4015898886e140ad95f320ab4c07db2c" title="Destroy a CUDPP Plan.">cudppDestroyPlan()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">planHandle</td><td>Handle to plan for this scan </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_out</td><td>output of scan, in GPU memory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_in</td><td>input to scan, in GPU memory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>number of elements to scan </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CUDPPResult indicating success or error condition</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__public_interface.html#ga31fd56135f9c8f73da79af83a958f27c" title="Create a CUDPP plan.">cudppPlan</a>, <a class="el" href="group__public_interface.html#ga4015898886e140ad95f320ab4c07db2c" title="Destroy a CUDPP Plan.">cudppDestroyPlan</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaf71eb423ec3252ca122e5c01b055fa51"></a><!-- doxytag: member="cudpp.cpp::cudppSegmentedScan" ref="gaf71eb423ec3252ca122e5c01b055fa51" args="(const CUDPPHandle planHandle, void *d_out, const void *d_idata, const unsigned int *d_iflags, size_t numElements)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppSegmentedScan </td>
          <td>(</td>
          <td class="paramtype">const CUDPPHandle&#160;</td>
          <td class="paramname"><em>planHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>d_idata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>d_iflags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs a segmented scan operation of numElements on its input in GPU memory (d_idata) and places the output in GPU memory (d_out), with the scan parameters specified in the plan pointed to by planHandle. </p>
<p>The input to a segmented scan operation is an input array of data, an input array of flags which demarcate segments, a binary associative operator (like + or max), and an identity element for that operator (+'s identity is 0). The array of flags is the same length as the input with 1 marking the the first element of a segment and 0 otherwise. The output of segmented scan is the same size as its input. Informally, the output at each element is the result of operator applied to each input that comes before it in that segment. For instance, the output of segmented sum-scan at each element is the sum of all the input elements before that input in that segment.</p>
<p>More formally, for associative operator  &oplus; , <em>out<sub>i</sub></em> = <em>in<sub>k</sub></em>  &oplus;  <em>in<sub>k+1</sub></em>  &oplus;  ...  &oplus;  <em>in<sub>i-1</sub></em>. <em>k</em> is the index of the first element of the segment in which <em>i</em> lies</p>
<p>We support both "exclusive" and "inclusive" variants. For a segmented sum-scan, the exclusive variant computes the sum of all input elements before the current element in that segment, while the inclusive variant computes the sum of all input elements up to and including the current element, in that segment.</p>
<p>Before calling segmented scan, create an internal plan using <a class="el" href="group__public_interface.html#ga31fd56135f9c8f73da79af83a958f27c" title="Create a CUDPP plan.">cudppPlan()</a>.</p>
<p>After you are finished with the scan plan, clean up with <a class="el" href="group__public_interface.html#ga4015898886e140ad95f320ab4c07db2c" title="Destroy a CUDPP Plan.">cudppDestroyPlan()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">planHandle</td><td>Handle to plan for this scan </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_out</td><td>output of segmented scan, in GPU memory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_idata</td><td>input data to segmented scan, in GPU memory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_iflags</td><td>input flags to segmented scan, in GPU memory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>number of elements to perform segmented scan on </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CUDPPResult indicating success or error condition</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__public_interface.html#ga31fd56135f9c8f73da79af83a958f27c" title="Create a CUDPP plan.">cudppPlan</a>, <a class="el" href="group__public_interface.html#ga4015898886e140ad95f320ab4c07db2c" title="Destroy a CUDPP Plan.">cudppDestroyPlan</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gad9655b51dba16bc43b8adee4507dc1d0"></a><!-- doxytag: member="cudpp.cpp::cudppMultiScan" ref="gad9655b51dba16bc43b8adee4507dc1d0" args="(const CUDPPHandle planHandle, void *d_out, const void *d_in, size_t numElements, size_t numRows)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppMultiScan </td>
          <td>(</td>
          <td class="paramtype">const CUDPPHandle&#160;</td>
          <td class="paramname"><em>planHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>d_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numRows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs numRows parallel scan operations of numElements each on its input (d_in) and places the output in d_out, with the scan parameters set by config. Exactly like cudppScan except that it runs on multiple rows in parallel. </p>
<p>Note that to achieve good performance with cudppMultiScan one should allocate the device arrays passed to it so that all rows are aligned to the correct boundaries for the architecture the app is running on. The easy way to do this is to use cudaMallocPitch() to allocate a 2D array on the device. Use the <em>rowPitch</em> parameter to <a class="el" href="group__public_interface.html#ga31fd56135f9c8f73da79af83a958f27c" title="Create a CUDPP plan.">cudppPlan()</a> to specify this pitch. The easiest way is to pass the device pitch returned by cudaMallocPitch to <a class="el" href="group__public_interface.html#ga31fd56135f9c8f73da79af83a958f27c" title="Create a CUDPP plan.">cudppPlan()</a> via <em>rowPitch</em>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">planHandle</td><td>handle to <a class="el" href="class_c_u_d_p_p_scan_plan.html" title="Plan class for scan algorithm.">CUDPPScanPlan</a> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_out</td><td>output of scan, in GPU memory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_in</td><td>input to scan, in GPU memory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>number of elements (per row) to scan </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numRows</td><td>number of rows to scan in parallel </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CUDPPResult indicating success or error condition</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__public_interface.html#ga19f4711b5219ff1fd4851fda0398d547" title="Performs a scan operation of numElements on its input in GPU memory (d_in) and places the output in G...">cudppScan</a>, <a class="el" href="group__public_interface.html#ga31fd56135f9c8f73da79af83a958f27c" title="Create a CUDPP plan.">cudppPlan</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gab3fd0152a8e5b1860b1b7b09a3753ae0"></a><!-- doxytag: member="cudpp.cpp::cudppCompact" ref="gab3fd0152a8e5b1860b1b7b09a3753ae0" args="(const CUDPPHandle planHandle, void *d_out, size_t *d_numValidElements, const void *d_in, const unsigned int *d_isValid, size_t numElements)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppCompact </td>
          <td>(</td>
          <td class="paramtype">const CUDPPHandle&#160;</td>
          <td class="paramname"><em>planHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>d_numValidElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>d_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>d_isValid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given an array <em>d_in</em> and an array of 1/0 flags in <em>deviceValid</em>, returns a compacted array in <em>d_out</em> of corresponding only the "valid" values from <em>d_in</em>. </p>
<p>Takes as input an array of elements in GPU memory (<em>d_in</em>) and an equal-sized unsigned int array in GPU memory (<em>deviceValid</em>) that indicate which of those input elements are valid. The output is a packed array, in GPU memory, of only those elements marked as valid.</p>
<p>Internally, uses cudppScan.</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment"> d_in    = [ a b c d e f ]
 deviceValid = [ 1 0 1 1 0 1 ]
 d_out   = [ a c d f ]
</pre></div><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd>[MJH] We need to evaluate whether cudppCompact should be a core member of the public interface. It's not clear to me that what the user always wants is a final compacted array. Often one just wants the array of indices to which each input element should go in the output. The split() routine used in radix sort might make more sense to expose.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">planHandle</td><td>handle to <a class="el" href="class_c_u_d_p_p_compact_plan.html" title="Plan class for compact algorithm.">CUDPPCompactPlan</a> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_out</td><td>compacted output </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_numValidElements</td><td>set during cudppCompact; is set with the number of elements valid flags in the d_isValid input array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_in</td><td>input to compact </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_isValid</td><td>which elements in d_in are valid </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>number of elements in d_in </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CUDPPResult indicating success or error condition </dd></dl>

</div>
</div>
<a class="anchor" id="ga21d9b2b3c74daffbec52ef628f835313"></a><!-- doxytag: member="cudpp.cpp::cudppReduce" ref="ga21d9b2b3c74daffbec52ef628f835313" args="(const CUDPPHandle planHandle, void *d_out, const void *d_in, size_t numElements)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppReduce </td>
          <td>(</td>
          <td class="paramtype">const CUDPPHandle&#160;</td>
          <td class="paramname"><em>planHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>d_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reduces an array to a single element using a binary associative operator. </p>
<p>For example, if the operator is CUDPP_ADD, then: </p>
<div class="fragment"><pre class="fragment"> d_in    = [ 3 2 0 1 -4 5 0 -1 ]
 d_out   = [ 6 ]
</pre></div><p>If the operator is CUDPP_MIN, then: </p>
<div class="fragment"><pre class="fragment"> d_in    = [ 3 2 0 1 -4 5 0 -1 ]
 d_out   = [ -4 ]
</pre></div><p>Limits: <em>numElements</em> must be at least 1, and is currently limited only by the addressable memory in CUDA (and the output accuracy is limited by numerical precision).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">planHandle</td><td>handle to <a class="el" href="class_c_u_d_p_p_reduce_plan.html" title="Plan class for reduce algorithm.">CUDPPReducePlan</a> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_out</td><td>Output of reduce (a single element) in GPU memory. Must be a pointer to an array of at least a single element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_in</td><td>Input array to reduce in GPU memory. Must be a pointer to an array of at least <em>numElements</em> elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>the number of elements to reduce. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CUDPPResult indicating success or error condition</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__public_interface.html#ga31fd56135f9c8f73da79af83a958f27c" title="Create a CUDPP plan.">cudppPlan</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga234f3b894d9cc5a04bb48d886773a0f0"></a><!-- doxytag: member="cudpp.cpp::cudppSort" ref="ga234f3b894d9cc5a04bb48d886773a0f0" args="(const CUDPPHandle planHandle, void *d_keys, void *d_values, size_t numElements)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppSort </td>
          <td>(</td>
          <td class="paramtype">const CUDPPHandle&#160;</td>
          <td class="paramname"><em>planHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sorts key-value pairs or keys only. </p>
<p>Takes as input an array of keys in GPU memory (d_keys) and an optional array of corresponding values, and outputs sorted arrays of keys and (optionally) values in place. Key-value and key-only sort is selected through the configuration of the plan, using the options CUDPP_OPTION_KEYS_ONLY and CUDPP_OPTION_KEY_VALUE_PAIRS.</p>
<p>Supported key types are CUDPP_FLOAT and CUDPP_UINT. Values can be any 32-bit type (internally, values are treated only as a payload and cast to unsigned int).</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000007">Todo:</a></b></dt><dd>Determine if we need to provide an "out of place" sort interface.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">planHandle</td><td>handle to CUDPPSortPlan </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_keys</td><td>keys by which key-value pairs will be sorted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_values</td><td>values to be sorted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>number of elements in d_keys and d_values </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CUDPPResult indicating success or error condition</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__public_interface.html#ga31fd56135f9c8f73da79af83a958f27c" title="Create a CUDPP plan.">cudppPlan</a>, <a class="el" href="struct_c_u_d_p_p_configuration.html" title="Configuration struct used to specify algorithm, datatype, operator, and options when creating a plan ...">CUDPPConfiguration</a>, <a class="el" href="cudpp_8h.html#a6499e5c26f56db82f520367ae853462f" title="Algorithms supported by CUDPP. Used to create appropriate plans using cudppPlan.">CUDPPAlgorithm</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaeedaa3a7ec8bbd6770c6fbce3c4276c5"></a><!-- doxytag: member="cudpp.cpp::cudppSparseMatrixVectorMultiply" ref="gaeedaa3a7ec8bbd6770c6fbce3c4276c5" args="(const CUDPPHandle sparseMatrixHandle, void *d_y, const void *d_x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppSparseMatrixVectorMultiply </td>
          <td>(</td>
          <td class="paramtype">const CUDPPHandle&#160;</td>
          <td class="paramname"><em>sparseMatrixHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>d_x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform matrix-vector multiply y = A*x for arbitrary sparse matrix A and vector x. </p>
<p>Given a matrix object handle (which has been initialized using <a class="el" href="group__public_interface.html#gabc6c2587fe06dadd93fb1d69ba836d84" title="Create a CUDPP Sparse Matrix Object.">cudppSparseMatrix()</a>), This function multiplies the input vector <em>d_x</em> by the matrix referred to by <em>sparseMatrixHandle</em>, returning the result in <em>d_y</em>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sparseMatrixHandle</td><td>Handle to a sparse matrix object created with <a class="el" href="group__public_interface.html#gabc6c2587fe06dadd93fb1d69ba836d84" title="Create a CUDPP Sparse Matrix Object.">cudppSparseMatrix()</a> </td></tr>
    <tr><td class="paramname">d_y</td><td>The output vector, y </td></tr>
    <tr><td class="paramname">d_x</td><td>The input vector, x </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CUDPPResult indicating success or error condition</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__public_interface.html#gabc6c2587fe06dadd93fb1d69ba836d84" title="Create a CUDPP Sparse Matrix Object.">cudppSparseMatrix</a>, <a class="el" href="group__public_interface.html#gae0644c758120abaef0e2bb396f57cefb" title="Destroy a CUDPP Sparse Matrix Object.">cudppDestroySparseMatrix</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gac27c987891faceedf79598f744212c67"></a><!-- doxytag: member="cudpp.cpp::cudppRand" ref="gac27c987891faceedf79598f744212c67" args="(const CUDPPHandle planHandle, void *d_out, size_t numElements)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppRand </td>
          <td>(</td>
          <td class="paramtype">const CUDPPHandle&#160;</td>
          <td class="paramname"><em>planHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rand puts <em>numElements</em> random 32-bit elements into <em>d_out</em>. </p>
<p>Outputs <em>numElements</em> random values to <em>d_out</em>. <em>d_out</em> must be of type unsigned int, allocated in device memory.</p>
<p>The algorithm used for the random number generation is stored in <em>planHandle</em>. Depending on the specification of the pseudo random number generator(PRNG), the generator may have one or more seeds. To set the seed, use <a class="el" href="group__public_interface.html#ga9120af9942d2553d2f376ede0f7079dd" title="Sets the seed used for rand.">cudppRandSeed()</a>.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000008">Todo:</a></b></dt><dd>Currently only MD5 PRNG is supported. We may provide more rand routines in the future.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">planHandle</td><td>Handle to plan for rand </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>number of elements in d_out. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_out</td><td>output of rand, in GPU memory. Should be an array of unsigned integers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CUDPPResult indicating success or error condition</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__public_interface.html#ga31fd56135f9c8f73da79af83a958f27c" title="Create a CUDPP plan.">cudppPlan</a>, <a class="el" href="struct_c_u_d_p_p_configuration.html" title="Configuration struct used to specify algorithm, datatype, operator, and options when creating a plan ...">CUDPPConfiguration</a>, <a class="el" href="cudpp_8h.html#a6499e5c26f56db82f520367ae853462f" title="Algorithms supported by CUDPP. Used to create appropriate plans using cudppPlan.">CUDPPAlgorithm</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga9120af9942d2553d2f376ede0f7079dd"></a><!-- doxytag: member="cudpp.cpp::cudppRandSeed" ref="ga9120af9942d2553d2f376ede0f7079dd" args="(const CUDPPHandle planHandle, unsigned int seed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppRandSeed </td>
          <td>(</td>
          <td class="paramtype">const CUDPPHandle&#160;</td>
          <td class="paramname"><em>planHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the seed used for rand. </p>
<p>The seed is crucial to any random number generator as it allows a sequence of random numbers to be replicated. Since there may be multiple different rand algorithms in CUDPP, cudppRandSeed uses <em>planHandle</em> to determine which seed to set. Each rand algorithm has its own unique set of seeds depending on what the algorithm needs.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">planHandle</td><td>the handle to the plan which specifies which rand seed to set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seed</td><td>the value which the internal cudpp seed will be set to </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CUDPPResult indicating success or error condition </dd></dl>

</div>
</div>
<a class="anchor" id="gabd3c1f97e1d22839756fd2594aaefb56"></a><!-- doxytag: member="cudpp.cpp::cudppTridiagonal" ref="gabd3c1f97e1d22839756fd2594aaefb56" args="(CUDPPHandle planHandle, void *d_a, void *d_b, void *d_c, void *d_d, void *d_x, int systemSize, int numSystems)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppTridiagonal </td>
          <td>(</td>
          <td class="paramtype">CUDPPHandle&#160;</td>
          <td class="paramname"><em>planHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>systemSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numSystems</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Solves tridiagonal linear systems. </p>
<p>The solver uses a hybrid CR-PCR algorithm described in our papers "Fast
 Fast Tridiagonal Solvers on the GPU" and "A Hybrid Method for Solving 
 Tridiagonal Systems on the GPU". (See the <a class="el" href="index.html#references">References</a> bibliography). Please refer to the papers for a complete description of the basic CR (Cyclic Reduction) and PCR (Parallel Cyclic Reduction) algorithms and their hybrid variants.</p>
<ul>
<li>Both float and double data types are supported.</li>
<li>Both power-of-two and non-power-of-two system sizes are supported.</li>
<li>The maximum system size could be limited by the maximum number of threads of a CUDA block, the number of registers per multiprocessor, and the amount of shared memory available. For example, on the GTX 280 GPU, the maximum system size is 512 for the float datatype, and 256 for the double datatype, which is limited by the size of shared memory in this case.</li>
<li>The maximum number of systems is 65535, that is the maximum number of one-dimensional blocks that could be launched in a kernel call. Users could launch the kernel multiple times to solve more systems if required.</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_x</td><td>Solution vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">planHandle</td><td>Handle to plan for tridiagonal solver </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_a</td><td>Lower diagonal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_b</td><td>Main diagonal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_c</td><td>Upper diagonal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_d</td><td>Right hand side </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">systemSize</td><td>The size of the linear system </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numSystems</td><td>The number of systems to be solved </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CUDPPResult indicating success or error condition</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__public_interface.html#ga31fd56135f9c8f73da79af83a958f27c" title="Create a CUDPP plan.">cudppPlan</a>, <a class="el" href="struct_c_u_d_p_p_configuration.html" title="Configuration struct used to specify algorithm, datatype, operator, and options when creating a plan ...">CUDPPConfiguration</a>, <a class="el" href="cudpp_8h.html#a6499e5c26f56db82f520367ae853462f" title="Algorithms supported by CUDPP. Used to create appropriate plans using cudppPlan.">CUDPPAlgorithm</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga9156a26943f99d0fff44d218129631b4"></a><!-- doxytag: member="cudpp_manager.cpp::cudppCreate" ref="ga9156a26943f99d0fff44d218129631b4" args="(CUDPPHandle *theCudpp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppCreate </td>
          <td>(</td>
          <td class="paramtype">CUDPPHandle *&#160;</td>
          <td class="paramname"><em>theCudpp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an instance of the CUDPP library, and returns a handle. </p>
<p><a class="el" href="group__public_interface.html#ga9156a26943f99d0fff44d218129631b4" title="Creates an instance of the CUDPP library, and returns a handle.">cudppCreate()</a> must be called before any other CUDPP function. In a multi-GPU application that uses multiple CUDA context, <a class="el" href="group__public_interface.html#ga9156a26943f99d0fff44d218129631b4" title="Creates an instance of the CUDPP library, and returns a handle.">cudppCreate()</a> must be called once for each CUDA context. Each call returns a different handle, because each CUDA context (and the host thread that owns it) must use a separate instance of the CUDPP library.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">theCudpp</td><td>a pointer to the CUDPPHandle for the created CUDPP instance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CUDPPResult indicating success or error condition </dd></dl>

</div>
</div>
<a class="anchor" id="ga8b98b05d585860ec4fcc44472244d01b"></a><!-- doxytag: member="cudpp_manager.cpp::cudppDestroy" ref="ga8b98b05d585860ec4fcc44472244d01b" args="(CUDPPHandle theCudpp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppDestroy </td>
          <td>(</td>
          <td class="paramtype">CUDPPHandle&#160;</td>
          <td class="paramname"><em>theCudpp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroys an instance of the CUDPP library given its handle. </p>
<p><a class="el" href="group__public_interface.html#ga8b98b05d585860ec4fcc44472244d01b" title="Destroys an instance of the CUDPP library given its handle.">cudppDestroy()</a> should be called once for each handle created using <a class="el" href="group__public_interface.html#ga9156a26943f99d0fff44d218129631b4" title="Creates an instance of the CUDPP library, and returns a handle.">cudppCreate()</a>, to ensure proper resource cleanup of all library instances.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theCudpp</td><td>the handle to the CUDPP instance to destroy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CUDPPResult indicating success or error condition </dd></dl>

</div>
</div>
<a class="anchor" id="ga31fd56135f9c8f73da79af83a958f27c"></a><!-- doxytag: member="cudpp_plan.cpp::cudppPlan" ref="ga31fd56135f9c8f73da79af83a958f27c" args="(const CUDPPHandle cudppHandle, CUDPPHandle *planHandle, CUDPPConfiguration config, size_t numElements, size_t numRows, size_t rowPitch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppPlan </td>
          <td>(</td>
          <td class="paramtype">const CUDPPHandle&#160;</td>
          <td class="paramname"><em>cudppHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CUDPPHandle *&#160;</td>
          <td class="paramname"><em>planHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_u_d_p_p_configuration.html">CUDPPConfiguration</a>&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rowPitch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a CUDPP plan. </p>
<p>A plan is a data structure containing state and intermediate storage space that CUDPP uses to execute algorithms on data. A plan is created by passing to <a class="el" href="group__public_interface.html#ga31fd56135f9c8f73da79af83a958f27c" title="Create a CUDPP plan.">cudppPlan()</a> a <a class="el" href="struct_c_u_d_p_p_configuration.html" title="Configuration struct used to specify algorithm, datatype, operator, and options when creating a plan ...">CUDPPConfiguration</a> that specifies the algorithm, operator, datatype, and options. The size of the data must also be passed to <a class="el" href="group__public_interface.html#ga31fd56135f9c8f73da79af83a958f27c" title="Create a CUDPP plan.">cudppPlan()</a>, in the <em>numElements</em>, <em>numRows</em>, and <em>rowPitch</em> arguments. These sizes are used to allocate internal storage space at the time the plan is created. The CUDPP planner may use the sizes, options, and information about the present hardware to choose optimal settings.</p>
<p>Note that <em>numElements</em> is the maximum size of the array to be processed with this plan. That means that a plan may be re-used to process (for example, to sort or scan) smaller arrays.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">planHandle</td><td>A pointer to an opaque handle to the internal plan </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cudppHandle</td><td>A handle to an instance of the CUDPP library used for resource management </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>The configuration struct specifying algorithm and options </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>The maximum number of elements to be processed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numRows</td><td>The number of rows (for 2D operations) to be processed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rowPitch</td><td>The pitch of the rows of input data, in elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CUDPPResult indicating success or error condition </dd></dl>

</div>
</div>
<a class="anchor" id="ga4015898886e140ad95f320ab4c07db2c"></a><!-- doxytag: member="cudpp_plan.cpp::cudppDestroyPlan" ref="ga4015898886e140ad95f320ab4c07db2c" args="(CUDPPHandle planHandle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppDestroyPlan </td>
          <td>(</td>
          <td class="paramtype">CUDPPHandle&#160;</td>
          <td class="paramname"><em>planHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroy a CUDPP Plan. </p>
<p>Deletes the plan referred to by <em>planHandle</em> and all associated internal storage.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">planHandle</td><td>The CUDPPHandle to the plan to be destroyed </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CUDPPResult indicating success or error condition </dd></dl>

</div>
</div>
<a class="anchor" id="gabc6c2587fe06dadd93fb1d69ba836d84"></a><!-- doxytag: member="cudpp_plan.cpp::cudppSparseMatrix" ref="gabc6c2587fe06dadd93fb1d69ba836d84" args="(const CUDPPHandle cudppHandle, CUDPPHandle *sparseMatrixHandle, CUDPPConfiguration config, size_t numNonZeroElements, size_t numRows, const void *A, const unsigned int *h_rowIndices, const unsigned int *h_indices)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppSparseMatrix </td>
          <td>(</td>
          <td class="paramtype">const CUDPPHandle&#160;</td>
          <td class="paramname"><em>cudppHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CUDPPHandle *&#160;</td>
          <td class="paramname"><em>sparseMatrixHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_u_d_p_p_configuration.html">CUDPPConfiguration</a>&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numNonZeroElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>h_rowIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>h_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a CUDPP Sparse Matrix Object. </p>
<p>The sparse matrix plan is a data structure containing state and intermediate storage space that CUDPP uses to perform sparse matrix dense vector multiply. This plan is created by passing to CUDPPSparseMatrixVectorMultiplyPlan() a <a class="el" href="struct_c_u_d_p_p_configuration.html" title="Configuration struct used to specify algorithm, datatype, operator, and options when creating a plan ...">CUDPPConfiguration</a> that specifies the algorithm (sprarse matrix-dense vector multiply) and datatype, along with the sparse matrix itself in CSR format. The number of non-zero elements in the sparse matrix must also be passed as <em>numNonZeroElements</em>. This is used to allocate internal storage space at the time the sparse matrix plan is created.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">sparseMatrixHandle</td><td>A pointer to an opaque handle to the sparse matrix object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cudppHandle</td><td>A handle to an instance of the CUDPP library used for resource management </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>The configuration struct specifying algorithm and options </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numNonZeroElements</td><td>The number of non zero elements in the sparse matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numRows</td><td>This is the number of rows in y, x and A for y = A * x </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>The matrix data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">h_rowIndices</td><td>An array containing the index of the start of each row in <em>A</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">h_indices</td><td>An array containing the index of each nonzero element in <em>A</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CUDPPResult indicating success or error condition </dd></dl>

</div>
</div>
<a class="anchor" id="gae0644c758120abaef0e2bb396f57cefb"></a><!-- doxytag: member="cudpp_plan.cpp::cudppDestroySparseMatrix" ref="gae0644c758120abaef0e2bb396f57cefb" args="(CUDPPHandle sparseMatrixHandle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppDestroySparseMatrix </td>
          <td>(</td>
          <td class="paramtype">CUDPPHandle&#160;</td>
          <td class="paramname"><em>sparseMatrixHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroy a CUDPP Sparse Matrix Object. </p>
<p>Deletes the sparse matrix data and plan referred to by <em>sparseMatrixHandle</em> and all associated internal storage.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sparseMatrixHandle</td><td>The CUDPPHandle to the matrix object to be destroyed </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CUDPPResult indicating success or error condition </dd></dl>

</div>
</div>
<a class="anchor" id="ga0cd993f24223a9e5b59fc84bff5be22b"></a><!-- doxytag: member="cudpp_hash.cpp::cudppHashTable" ref="ga0cd993f24223a9e5b59fc84bff5be22b" args="(CUDPPHandle cudppHandle, CUDPPHandle *plan, const CUDPPHashTableConfig *config)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppHashTable </td>
          <td>(</td>
          <td class="paramtype">CUDPPHandle&#160;</td>
          <td class="paramname"><em>cudppHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CUDPPHandle *&#160;</td>
          <td class="paramname"><em>plan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_c_u_d_p_p_hash_table_config.html">CUDPPHashTableConfig</a> *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a CUDPP hash table in GPU memory given an input hash table configuration; returns the <em>plan</em> for that hash table. </p>
<p>Requires a CUDPPHandle for the CUDPP instance (to ensure thread safety); call <a class="el" href="group__public_interface.html#ga9156a26943f99d0fff44d218129631b4" title="Creates an instance of the CUDPP library, and returns a handle.">cudppCreate()</a> to get this handle.</p>
<p>The hash table implementation requires hardware capability 2.0 or higher (64-bit atomic operations).</p>
<p>Hash table types and input parameters are discussed in CUDPPHashTableType and <a class="el" href="struct_c_u_d_p_p_hash_table_config.html" title="Configuration struct for creating a hash table (CUDPPHashTable())">CUDPPHashTableConfig</a>.</p>
<p>After you are finished with the hash table, clean up with <a class="el" href="group__public_interface.html#gac78326e26664036e8526de8f7a662c0f" title="Destroys a hash table given its handle.">cudppDestroyHashTable()</a>.</p>
<p>See <a class="el" href="hash_overview.html">Overview of CUDPP hash tables</a> for an overview of CUDPP's hash table support.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cudppHandle</td><td>Handle to CUDPP instance </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">plan</td><td>Handle to hash table instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>Configuration for hash table to be created </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CUDPPResult indicating if creation was successful</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__public_interface.html#ga9156a26943f99d0fff44d218129631b4" title="Creates an instance of the CUDPP library, and returns a handle.">cudppCreate</a>, <a class="el" href="group__public_interface.html#gac78326e26664036e8526de8f7a662c0f" title="Destroys a hash table given its handle.">cudppDestroyHashTable</a>, <a class="el" href="cudpp__hash_8h.html#aafb866af39fe4f36e06273bd472fc3ec" title="Supported types of hash tables.">CUDPPHashTableType</a>, <a class="el" href="struct_c_u_d_p_p_hash_table_config.html" title="Configuration struct for creating a hash table (CUDPPHashTable())">CUDPPHashTableConfig</a>, <a class="el" href="hash_overview.html">Overview of CUDPP hash tables</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaa93793870394fdb90859d6f1e0ff662b"></a><!-- doxytag: member="cudpp_hash.cpp::cudppHashInsert" ref="gaa93793870394fdb90859d6f1e0ff662b" args="(CUDPPHandle plan, const void *d_keys, const void *d_vals, size_t num)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppHashInsert </td>
          <td>(</td>
          <td class="paramtype">CUDPPHandle&#160;</td>
          <td class="paramname"><em>plan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>d_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>d_vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inserts keys and values into a CUDPP hash table. </p>
<p>Requires a CUDPPHandle for the hash table instance; call <a class="el" href="group__public_interface.html#ga0cd993f24223a9e5b59fc84bff5be22b" title="Creates a CUDPP hash table in GPU memory given an input hash table configuration; returns the plan fo...">cudppHashTable()</a> to create the hash table and get this handle.</p>
<p><em>d_keys</em> and <em>d_values</em> should be in GPU memory. These should be pointers to arrays of unsigned ints.</p>
<p>Calls HashTable::Build internally.</p>
<p>See <a class="el" href="hash_overview.html">Overview of CUDPP hash tables</a> for an overview of CUDPP's hash table support.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Handle to hash table instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_keys</td><td>GPU pointer to keys to be inserted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_vals</td><td>GPU pointer to values to be inserted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>Number of keys/values to be inserted </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CUDPPResult indicating if insertion was successful</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__public_interface.html#ga0cd993f24223a9e5b59fc84bff5be22b" title="Creates a CUDPP hash table in GPU memory given an input hash table configuration; returns the plan fo...">cudppHashTable</a>, <a class="el" href="group__public_interface.html#ga8a351e4f3c9d69e3111c3463784e7ebe" title="Retrieves values, given keys, from a CUDPP hash table.">cudppHashRetrieve</a>, HashTable::Build, CompactingHashTable::Build, MultivalueHashTable::Build, <a class="el" href="hash_overview.html">Overview of CUDPP hash tables</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga8a351e4f3c9d69e3111c3463784e7ebe"></a><!-- doxytag: member="cudpp_hash.cpp::cudppHashRetrieve" ref="ga8a351e4f3c9d69e3111c3463784e7ebe" args="(CUDPPHandle plan, const void *d_keys, void *d_vals, size_t num)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppHashRetrieve </td>
          <td>(</td>
          <td class="paramtype">CUDPPHandle&#160;</td>
          <td class="paramname"><em>plan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>d_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves values, given keys, from a CUDPP hash table. </p>
<p>Requires a CUDPPHandle for the hash table instance; call <a class="el" href="group__public_interface.html#ga0cd993f24223a9e5b59fc84bff5be22b" title="Creates a CUDPP hash table in GPU memory given an input hash table configuration; returns the plan fo...">cudppHashTable()</a> to create the hash table and get this handle.</p>
<p><em>d_keys</em> and <em>d_values</em> should be in GPU memory. These should be pointers to arrays of unsigned ints.</p>
<p>Calls HashTable::Retrieve internally.</p>
<p>See <a class="el" href="hash_overview.html">Overview of CUDPP hash tables</a> for an overview of CUDPP's hash table support.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Handle to hash table instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_keys</td><td>GPU pointer to keys to be retrieved </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_vals</td><td>GPU pointer to values to be retrieved </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>Number of keys/values to be retrieved </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CUDPPResult indicating if retrieval was successful</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__public_interface.html#ga0cd993f24223a9e5b59fc84bff5be22b" title="Creates a CUDPP hash table in GPU memory given an input hash table configuration; returns the plan fo...">cudppHashTable</a>, cudppHashBuild, HashTable::Retrieve, CompactingHashTable::Retrieve, MultivalueHashTable::Retrieve, <a class="el" href="hash_overview.html">Overview of CUDPP hash tables</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gac78326e26664036e8526de8f7a662c0f"></a><!-- doxytag: member="cudpp_hash.cpp::cudppDestroyHashTable" ref="gac78326e26664036e8526de8f7a662c0f" args="(CUDPPHandle cudppHandle, CUDPPHandle plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppDestroyHashTable </td>
          <td>(</td>
          <td class="paramtype">CUDPPHandle&#160;</td>
          <td class="paramname"><em>cudppHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CUDPPHandle&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroys a hash table given its handle. </p>
<p>Requires a CUDPPHandle for the CUDPP instance (to ensure thread safety); call <a class="el" href="group__public_interface.html#ga9156a26943f99d0fff44d218129631b4" title="Creates an instance of the CUDPP library, and returns a handle.">cudppCreate()</a> to get this handle.</p>
<p>Requires a CUDPPHandle for the hash table instance; call <a class="el" href="group__public_interface.html#ga0cd993f24223a9e5b59fc84bff5be22b" title="Creates a CUDPP hash table in GPU memory given an input hash table configuration; returns the plan fo...">cudppHashTable()</a> to get this handle.</p>
<p>See <a class="el" href="hash_overview.html">Overview of CUDPP hash tables</a> for an overview of CUDPP's hash table support.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cudppHandle</td><td>Handle to CUDPP instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Handle to hash table instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CUDPPResult indicating if destruction was successful</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__public_interface.html#ga0cd993f24223a9e5b59fc84bff5be22b" title="Creates a CUDPP hash table in GPU memory given an input hash table configuration; returns the plan fo...">cudppHashTable</a>, <a class="el" href="hash_overview.html">Overview of CUDPP hash tables</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaab1189a6b1ce8ebb63c02ef46acd9595"></a><!-- doxytag: member="cudpp_hash.cpp::cudppMultivalueHashGetValuesSize" ref="gaab1189a6b1ce8ebb63c02ef46acd9595" args="(CUDPPHandle plan, unsigned int *size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppMultivalueHashGetValuesSize </td>
          <td>(</td>
          <td class="paramtype">CUDPPHandle&#160;</td>
          <td class="paramname"><em>plan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the size of the values array in a multivalue hash table. </p>
<p>Only relevant for multivalue hash tables.</p>
<p>Requires a CUDPPHandle for the hash table instance; call <a class="el" href="group__public_interface.html#ga0cd993f24223a9e5b59fc84bff5be22b" title="Creates a CUDPP hash table in GPU memory given an input hash table configuration; returns the plan fo...">cudppHashTable()</a> to get this handle.</p>
<p>See <a class="el" href="hash_overview.html">Overview of CUDPP hash tables</a> for an overview of CUDPP's hash table support.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Handle to hash table instance </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">size</td><td>Pointer to size of multivalue hash table </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CUDPPResult indicating if operation was successful</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__public_interface.html#ga0cd993f24223a9e5b59fc84bff5be22b" title="Creates a CUDPP hash table in GPU memory given an input hash table configuration; returns the plan fo...">cudppHashTable</a>, <a class="el" href="group__public_interface.html#ga6b5e657c472ed38442fe45861836bc9d" title="Retrieves a pointer to the values array in a multivalue hash table.">cudppMultivalueHashGetAllValues</a>, <a class="el" href="hash_overview.html">Overview of CUDPP hash tables</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga6b5e657c472ed38442fe45861836bc9d"></a><!-- doxytag: member="cudpp_hash.cpp::cudppMultivalueHashGetAllValues" ref="ga6b5e657c472ed38442fe45861836bc9d" args="(CUDPPHandle plan, unsigned int **d_vals)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppMultivalueHashGetAllValues </td>
          <td>(</td>
          <td class="paramtype">CUDPPHandle&#160;</td>
          <td class="paramname"><em>plan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int **&#160;</td>
          <td class="paramname"><em>d_vals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves a pointer to the values array in a multivalue hash table. </p>
<p>Only relevant for multivalue hash tables.</p>
<p>Requires a CUDPPHandle for the hash table instance; call <a class="el" href="group__public_interface.html#ga0cd993f24223a9e5b59fc84bff5be22b" title="Creates a CUDPP hash table in GPU memory given an input hash table configuration; returns the plan fo...">cudppHashTable()</a> to get this handle.</p>
<p>See <a class="el" href="hash_overview.html">Overview of CUDPP hash tables</a> for an overview of CUDPP's hash table support.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Handle to hash table instance </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_vals</td><td>Pointer to pointer of values (in GPU memory) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CUDPPResult indicating if operation was successful</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__public_interface.html#ga0cd993f24223a9e5b59fc84bff5be22b" title="Creates a CUDPP hash table in GPU memory given an input hash table configuration; returns the plan fo...">cudppHashTable</a>, <a class="el" href="group__public_interface.html#gaab1189a6b1ce8ebb63c02ef46acd9595" title="Retrieves the size of the values array in a multivalue hash table.">cudppMultivalueHashGetValuesSize</a>, <a class="el" href="hash_overview.html">Overview of CUDPP hash tables</a> </dd></dl>

</div>
</div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Tue Aug 9 2011 11:59:20 for CUDPP by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
