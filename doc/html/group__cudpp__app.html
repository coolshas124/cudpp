<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>CUDPP: CUDPP Application-Level API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CUDPP&#160;<span id="projectnumber">2.0</span></div>
   <div id="projectbrief">CUDA Data-Parallel Primitives Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#groups">Modules</a>  </div>
  <div class="headertitle">
<div class="title">CUDPP Application-Level API</div>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cuda_h_t_1_1_cuckoo_hashing_1_1_hash_table.html">CudaHT::CuckooHashing::HashTable</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic hash table that stores one value for each key.  <a href="class_cuda_h_t_1_1_cuckoo_hashing_1_1_hash_table.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="groups"></a>
Modules</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__hash__data__structures.html">Hash Table Data Structures and Constants</a></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Compact Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga040dfdfedb09338ecbb6c154ce164717">calculateCompactLaunchParams</a> (const unsigned int numElements, unsigned int &amp;numThreads, unsigned int &amp;numBlocks, unsigned int &amp;numEltsPerBlock)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate launch parameters for <a class="el" href="group__cudpp__app.html#ga00003db78fb8a269263a5e1205257f40" title="Compact the non-zero elements of an array.">compactArray()</a>.  <a href="#ga040dfdfedb09338ecbb6c154ce164717"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga00003db78fb8a269263a5e1205257f40">compactArray</a> (T *d_out, size_t *d_numValidElements, const T *d_in, const unsigned int *d_isValid, size_t numElements, const <a class="el" href="class_c_u_d_p_p_compact_plan.html">CUDPPCompactPlan</a> *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compact the non-zero elements of an array.  <a href="#ga00003db78fb8a269263a5e1205257f40"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#gae84f008f74af507fb9da9568ee22bd21">allocCompactStorage</a> (<a class="el" href="class_c_u_d_p_p_compact_plan.html">CUDPPCompactPlan</a> *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate intermediate arrays used by <a class="el" href="group__public_interface.html#gab3fd0152a8e5b1860b1b7b09a3753ae0" title="Given an array d_in and an array of 1/0 flags in deviceValid, returns a compacted array in d_out of c...">cudppCompact()</a>.  <a href="#gae84f008f74af507fb9da9568ee22bd21"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga5f6b8e696bb6ec4d87d55046041dfb9e">freeCompactStorage</a> (<a class="el" href="class_c_u_d_p_p_compact_plan.html">CUDPPCompactPlan</a> *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate intermediate storage used by <a class="el" href="group__public_interface.html#gab3fd0152a8e5b1860b1b7b09a3753ae0" title="Given an array d_in and an array of 1/0 flags in deviceValid, returns a compacted array in d_out of c...">cudppCompact()</a>.  <a href="#ga5f6b8e696bb6ec4d87d55046041dfb9e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#gafccd7f148a985a1ec19b30cf1d00fdbf">cudppCompactDispatch</a> (void *d_out, size_t *d_numValidElements, const void *d_in, const unsigned int *d_isValid, size_t numElements, const <a class="el" href="class_c_u_d_p_p_compact_plan.html">CUDPPCompactPlan</a> *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch compactArray for the specified datatype.  <a href="#gafccd7f148a985a1ec19b30cf1d00fdbf"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
RadixSort Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#gaa6043ddac717a99c471bb3dc0fc3c0de">allocRadixSortStorage</a> (CUDPPRadixSortPlan *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">From the programmer-specified sort configuration, creates internal memory for performing the sort.  <a href="#gaa6043ddac717a99c471bb3dc0fc3c0de"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga5b103658becc8dbb8c5ca1026ff61598">freeRadixSortStorage</a> (CUDPPRadixSortPlan *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocates intermediate memory from allocRadixSortStorage.  <a href="#ga5b103658becc8dbb8c5ca1026ff61598"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga40828c556804c4367dfae5527b874e9b"></a><!-- doxytag: member="cudpp_app::runSort" ref="ga40828c556804c4367dfae5527b874e9b" args="(T *pkeys, unsigned int *pvals, size_t numElements, const CUDPPRadixSortPlan *plan)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>runSort</b> (T *pkeys, unsigned int *pvals, size_t numElements, const CUDPPRadixSortPlan *plan)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga75c1c0e157a23d4747fc2ae94570aab0">cudppRadixSortDispatch</a> (void *keys, void *values, size_t numElements, const CUDPPRadixSortPlan *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch function to perform a sort on an array with a specified configuration.  <a href="#ga75c1c0e157a23d4747fc2ae94570aab0"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Scan Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , bool isBackward, bool isExclusive, class Op &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#gaab8062495149d43064e1f03b4a8f15f9">scanArrayRecursive</a> (T *d_out, const T *d_in, T **d_blockSums, size_t numElements, size_t numRows, const size_t *rowPitches, int level)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform recursive scan on arbitrary size arrays.  <a href="#gaab8062495149d43064e1f03b4a8f15f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga344e15dee4b3b2351c40bd9cc732bed6">allocScanStorage</a> (<a class="el" href="class_c_u_d_p_p_scan_plan.html">CUDPPScanPlan</a> *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate intermediate arrays used by scan.  <a href="#ga344e15dee4b3b2351c40bd9cc732bed6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga399f5095b183ad026687fd227802ba5c">freeScanStorage</a> (<a class="el" href="class_c_u_d_p_p_scan_plan.html">CUDPPScanPlan</a> *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate intermediate block sums arrays in a <a class="el" href="class_c_u_d_p_p_scan_plan.html" title="Plan class for scan algorithm.">CUDPPScanPlan</a> object.  <a href="#ga399f5095b183ad026687fd227802ba5c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gaac1d3477c349371d25fe4f4df0007ffc"></a><!-- doxytag: member="cudpp_app::cudppScanDispatchOperator" ref="gaac1d3477c349371d25fe4f4df0007ffc" args="(void *d_out, const void *d_in, size_t numElements, size_t numRows, const CUDPPScanPlan *plan)" -->
template&lt;typename T , bool isBackward, bool isExclusive&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cudppScanDispatchOperator</b> (void *d_out, const void *d_in, size_t numElements, size_t numRows, const <a class="el" href="class_c_u_d_p_p_scan_plan.html">CUDPPScanPlan</a> *plan)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga50b953ee85f7bad7aec405447de288af"></a><!-- doxytag: member="cudpp_app::cudppScanDispatchType" ref="ga50b953ee85f7bad7aec405447de288af" args="(void *d_out, const void *d_in, size_t numElements, size_t numRows, const CUDPPScanPlan *plan)" -->
template&lt;bool isBackward, bool isExclusive&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cudppScanDispatchType</b> (void *d_out, const void *d_in, size_t numElements, size_t numRows, const <a class="el" href="class_c_u_d_p_p_scan_plan.html">CUDPPScanPlan</a> *plan)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga49485cb95e21695293a9c35f8355336d">cudppScanDispatch</a> (void *d_out, const void *d_in, size_t numElements, size_t numRows, const <a class="el" href="class_c_u_d_p_p_scan_plan.html">CUDPPScanPlan</a> *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch function to perform a scan (prefix sum) on an array with the specified configuration.  <a href="#ga49485cb95e21695293a9c35f8355336d"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Tridiagonal functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga2d0300574dee733d44099058671e1267"></a><!-- doxytag: member="cudpp_app::crpcrSharedSize" ref="ga2d0300574dee733d44099058671e1267" args="(unsigned int systemSizeOriginal)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><b>crpcrSharedSize</b> (unsigned int systemSizeOriginal)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga98079b338b2af21016a5cba9e00a0eb6">crpcr</a> (T *d_a, T *d_b, T *d_c, T *d_d, T *d_x, unsigned int systemSizeOriginal, unsigned int numSystems)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Hybrid CR-PCR solver (CRPCR)  <a href="#ga98079b338b2af21016a5cba9e00a0eb6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga0509ed92fe9640a9d7ea1ce9cfa639d3">cudppTridiagonalDispatch</a> (void *d_a, void *d_b, void *d_c, void *d_d, void *d_x, int systemSize, int numSystems, const <a class="el" href="class_c_u_d_p_p_tridiagonal_plan.html">CUDPPTridiagonalPlan</a> *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatches the tridiagonal function based on the plan.  <a href="#ga0509ed92fe9640a9d7ea1ce9cfa639d3"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>The CUDPP Application-Level API contains functions that run on the host CPU and invoke GPU routines in the CUDPP <a class="el" href="group__cudpp__kernel.html">Kernel-Level API</a>. Application-Level API functions are used by CUDPP <a class="el" href="group__public_interface.html">Public Interface</a> functions to implement CUDPP's core functionality. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga040dfdfedb09338ecbb6c154ce164717"></a><!-- doxytag: member="compact_app.cu::calculateCompactLaunchParams" ref="ga040dfdfedb09338ecbb6c154ce164717" args="(const unsigned int numElements, unsigned int &amp;numThreads, unsigned int &amp;numBlocks, unsigned int &amp;numEltsPerBlock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void calculateCompactLaunchParams </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>numThreads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>numBlocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>numEltsPerBlock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate launch parameters for <a class="el" href="group__cudpp__app.html#ga00003db78fb8a269263a5e1205257f40" title="Compact the non-zero elements of an array.">compactArray()</a>. </p>
<p>Calculates the block size and number of blocks from the total number of elements and the maximum threads per block. Called by <a class="el" href="group__cudpp__app.html#ga00003db78fb8a269263a5e1205257f40" title="Compact the non-zero elements of an array.">compactArray()</a>.</p>
<p>The calculation is pretty straightforward - the number of blocks is calculated by dividing the number of input elements by the product of the number of threads in each CTA and the number of elements each thread will process. numThreads and numEltsPerBlock are also simple to calculate. Please note that in cases where numElements is not an exact multiple of SCAN_ELTS_PER_THREAD * CTA_SIZE we would have threads which do nothing or have a thread which will process less than SCAN_ELTS_PER_THREAD elements.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of elements to sort </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">numThreads</td><td>Number of threads in each block </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">numBlocks</td><td>Number of blocks </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">numEltsPerBlock</td><td>Number of elements processed per block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga00003db78fb8a269263a5e1205257f40"></a><!-- doxytag: member="compact_app.cu::compactArray" ref="ga00003db78fb8a269263a5e1205257f40" args="(T *d_out, size_t *d_numValidElements, const T *d_in, const unsigned int *d_isValid, size_t numElements, const CUDPPCompactPlan *plan)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void compactArray </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>d_numValidElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>d_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>d_isValid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_u_d_p_p_compact_plan.html">CUDPPCompactPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compact the non-zero elements of an array. </p>
<p>Given an input array <em>d_in</em>, <a class="el" href="group__cudpp__app.html#ga00003db78fb8a269263a5e1205257f40" title="Compact the non-zero elements of an array.">compactArray()</a> outputs a compacted version which does not have null (zero) elements. Also ouputs the number of non-zero elements in the compacted array. Called by <a class="el" href="group__cudpp__app.html#gafccd7f148a985a1ec19b30cf1d00fdbf" title="Dispatch compactArray for the specified datatype.">cudppCompactDispatch()</a>.</p>
<p>The algorithm is straightforward, involving two steps (most of the complexity is hidden in scan, invoked with <a class="el" href="group__cudpp__app.html#ga49485cb95e21695293a9c35f8355336d" title="Dispatch function to perform a scan (prefix sum) on an array with the specified configuration.">cudppScanDispatch()</a> ).</p>
<ol type="1">
<li>scanArray() performs a prefix sum on <em>d_isValid</em> to compute output indices.</li>
<li><a class="el" href="group__cudpp__kernel.html#ga02aca9cfcac6799d445c857626e7d317" title="Consolidate non-null elements - for each non-null element in d_in write it to d_out, in the position specified by d_isValid. Called by compactArray().">compactData()</a> takes <em>d_in</em> and an intermediate array of output indices as input and writes the values with valid flags in <em>d_isValid</em> into <em>d_out</em> using the output indices.</li>
</ol>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_out</td><td>Array of compacted non-null elements </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_numValidElements</td><td>Pointer to unsigned int to store number of non-null elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_in</td><td>Input array </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_isValid</td><td>Array of flags, 1 for each non-null element, 0 for each null element. Same length as <em>d_in</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of elements in input array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to the plan object used for this compact </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae84f008f74af507fb9da9568ee22bd21"></a><!-- doxytag: member="compact_app.cu::allocCompactStorage" ref="gae84f008f74af507fb9da9568ee22bd21" args="(CUDPPCompactPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void allocCompactStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_u_d_p_p_compact_plan.html">CUDPPCompactPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate intermediate arrays used by <a class="el" href="group__public_interface.html#gab3fd0152a8e5b1860b1b7b09a3753ae0" title="Given an array d_in and an array of 1/0 flags in deviceValid, returns a compacted array in d_out of c...">cudppCompact()</a>. </p>
<p>In addition to the internal <a class="el" href="class_c_u_d_p_p_scan_plan.html" title="Plan class for scan algorithm.">CUDPPScanPlan</a> contained in <a class="el" href="class_c_u_d_p_p_compact_plan.html" title="Plan class for compact algorithm.">CUDPPCompactPlan</a>, CUDPPCompact also needs a temporary device array of output indices, which is allocated by this function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_compact_plan.html" title="Plan class for compact algorithm.">CUDPPCompactPlan</a> object within which intermediate storage is allocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5f6b8e696bb6ec4d87d55046041dfb9e"></a><!-- doxytag: member="compact_app.cu::freeCompactStorage" ref="ga5f6b8e696bb6ec4d87d55046041dfb9e" args="(CUDPPCompactPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freeCompactStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_u_d_p_p_compact_plan.html">CUDPPCompactPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deallocate intermediate storage used by <a class="el" href="group__public_interface.html#gab3fd0152a8e5b1860b1b7b09a3753ae0" title="Given an array d_in and an array of 1/0 flags in deviceValid, returns a compacted array in d_out of c...">cudppCompact()</a>. </p>
<p>Deallocates the output indices array allocated by <a class="el" href="group__cudpp__app.html#gae84f008f74af507fb9da9568ee22bd21" title="Allocate intermediate arrays used by cudppCompact().">allocCompactStorage()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_compact_plan.html" title="Plan class for compact algorithm.">CUDPPCompactPlan</a> object initialized by <a class="el" href="group__cudpp__app.html#gae84f008f74af507fb9da9568ee22bd21" title="Allocate intermediate arrays used by cudppCompact().">allocCompactStorage()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafccd7f148a985a1ec19b30cf1d00fdbf"></a><!-- doxytag: member="compact_app.cu::cudppCompactDispatch" ref="gafccd7f148a985a1ec19b30cf1d00fdbf" args="(void *d_out, size_t *d_numValidElements, const void *d_in, const unsigned int *d_isValid, size_t numElements, const CUDPPCompactPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudppCompactDispatch </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>d_numValidElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>d_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>d_isValid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_u_d_p_p_compact_plan.html">CUDPPCompactPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dispatch compactArray for the specified datatype. </p>
<p>A thin wrapper on top of compactArray which calls <a class="el" href="group__cudpp__app.html#ga00003db78fb8a269263a5e1205257f40" title="Compact the non-zero elements of an array.">compactArray()</a> for the data type specified in <em>config</em>. This is the app-level interface to compact used by <a class="el" href="group__public_interface.html#gab3fd0152a8e5b1860b1b7b09a3753ae0" title="Given an array d_in and an array of 1/0 flags in deviceValid, returns a compacted array in d_out of c...">cudppCompact()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_out</td><td>Compacted array of non-zero elements </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_numValidElements</td><td>Pointer to an unsigned int to store the number of non-zero elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_in</td><td>Input array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_isValid</td><td>Array of boolean valid flags with same length as <em>d_in</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of elements to compact </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to plan object for this compact </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa6043ddac717a99c471bb3dc0fc3c0de"></a><!-- doxytag: member="radixsort_app.cu::allocRadixSortStorage" ref="gaa6043ddac717a99c471bb3dc0fc3c0de" args="(CUDPPRadixSortPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void allocRadixSortStorage </td>
          <td>(</td>
          <td class="paramtype">CUDPPRadixSortPlan *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>From the programmer-specified sort configuration, creates internal memory for performing the sort. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to CUDPPRadixSortPlan object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5b103658becc8dbb8c5ca1026ff61598"></a><!-- doxytag: member="radixsort_app.cu::freeRadixSortStorage" ref="ga5b103658becc8dbb8c5ca1026ff61598" args="(CUDPPRadixSortPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freeRadixSortStorage </td>
          <td>(</td>
          <td class="paramtype">CUDPPRadixSortPlan *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deallocates intermediate memory from allocRadixSortStorage. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to CUDPPRadixSortPlan object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga75c1c0e157a23d4747fc2ae94570aab0"></a><!-- doxytag: member="radixsort_app.cu::cudppRadixSortDispatch" ref="ga75c1c0e157a23d4747fc2ae94570aab0" args="(void *keys, void *values, size_t numElements, const CUDPPRadixSortPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudppRadixSortDispatch </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CUDPPRadixSortPlan *&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dispatch function to perform a sort on an array with a specified configuration. </p>
<p>This is the dispatch routine which calls radixSort...() with appropriate template parameters and arguments as specified by the plan. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">keys</td><td>Keys to be sorted. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">values</td><td>Associated values to be sorted (through keys). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of elements in the sort. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Configuration information for RadixSort. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaab8062495149d43064e1f03b4a8f15f9"></a><!-- doxytag: member="scan_app.cu::scanArrayRecursive" ref="gaab8062495149d43064e1f03b4a8f15f9" args="(T *d_out, const T *d_in, T **d_blockSums, size_t numElements, size_t numRows, const size_t *rowPitches, int level)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool isBackward, bool isExclusive, class Op &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void scanArrayRecursive </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>d_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T **&#160;</td>
          <td class="paramname"><em>d_blockSums</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>rowPitches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform recursive scan on arbitrary size arrays. </p>
<p>This is the CPU-side workhorse function of the scan engine. This function invokes the CUDA kernels which perform the scan on individual blocks.</p>
<p>Scans of large arrays must be split (possibly recursively) into a hierarchy of block scans, where each block is scanned by a single CUDA thread block. At each recursive level of the scanArrayRecursive first invokes a kernel to scan all blocks of that level, and if the level has more than one block, it calls itself recursively. On returning from each recursive level, the total sum of each block from the level below is added to all elements of the corresponding block in this level. See "Parallel Prefix Sum (Scan) in CUDA" for more information (see <a class="el" href="index.html#references">References</a> ).</p>
<p>Template parameter <em>T</em> is the datatype; <em>isBackward</em> specifies backward or forward scan; <em>isExclusive</em> specifies exclusive or inclusive scan, and <em>op</em> specifies the binary associative operator to be used.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_out</td><td>The output array for the scan results </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_in</td><td>The input array to be scanned </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_blockSums</td><td>Array of arrays of per-block sums (one array per recursive level, allocated by <a class="el" href="group__cudpp__app.html#ga344e15dee4b3b2351c40bd9cc732bed6" title="Allocate intermediate arrays used by scan.">allocScanStorage()</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>The number of elements in the array to scan </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numRows</td><td>The number of rows in the array to scan </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rowPitches</td><td>Array of row pitches (one array per recursive level, allocated by <a class="el" href="group__cudpp__app.html#ga344e15dee4b3b2351c40bd9cc732bed6" title="Allocate intermediate arrays used by scan.">allocScanStorage()</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>The current recursive level of the scan </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga344e15dee4b3b2351c40bd9cc732bed6"></a><!-- doxytag: member="scan_app.cu::allocScanStorage" ref="ga344e15dee4b3b2351c40bd9cc732bed6" args="(CUDPPScanPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void allocScanStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_u_d_p_p_scan_plan.html">CUDPPScanPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate intermediate arrays used by scan. </p>
<p>Scans of large arrays must be split (possibly recursively) into a hierarchy of block scans, where each block is scanned by a single CUDA thread block. At each recursive level of the scan, we need an array in which to store the total sums of all blocks in that level. This function computes the amount of storage needed and allocates it.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_scan_plan.html" title="Plan class for scan algorithm.">CUDPPScanPlan</a> object containing options and number of elements, which is used to compute storage requirements, and within which intermediate storage is allocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga399f5095b183ad026687fd227802ba5c"></a><!-- doxytag: member="scan_app.cu::freeScanStorage" ref="ga399f5095b183ad026687fd227802ba5c" args="(CUDPPScanPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freeScanStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_u_d_p_p_scan_plan.html">CUDPPScanPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deallocate intermediate block sums arrays in a <a class="el" href="class_c_u_d_p_p_scan_plan.html" title="Plan class for scan algorithm.">CUDPPScanPlan</a> object. </p>
<p>These arrays must have been allocated by <a class="el" href="group__cudpp__app.html#ga344e15dee4b3b2351c40bd9cc732bed6" title="Allocate intermediate arrays used by scan.">allocScanStorage()</a>, which is called by the constructor of cudppScanPlan().</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_scan_plan.html" title="Plan class for scan algorithm.">CUDPPScanPlan</a> object initialized by <a class="el" href="group__cudpp__app.html#ga344e15dee4b3b2351c40bd9cc732bed6" title="Allocate intermediate arrays used by scan.">allocScanStorage()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga49485cb95e21695293a9c35f8355336d"></a><!-- doxytag: member="scan_app.cu::cudppScanDispatch" ref="ga49485cb95e21695293a9c35f8355336d" args="(void *d_out, const void *d_in, size_t numElements, size_t numRows, const CUDPPScanPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudppScanDispatch </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>d_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_u_d_p_p_scan_plan.html">CUDPPScanPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dispatch function to perform a scan (prefix sum) on an array with the specified configuration. </p>
<p>This is the dispatch routine which calls <a class="el" href="group__cudpp__app.html#gaab8062495149d43064e1f03b4a8f15f9" title="Perform recursive scan on arbitrary size arrays.">scanArrayRecursive()</a> with appropriate template parameters and arguments to achieve the scan as specified in <em>plan</em>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_out</td><td>The output array of scan results </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_in</td><td>The input array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>The number of elements to scan </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numRows</td><td>The number of rows to scan in parallel </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_scan_plan.html" title="Plan class for scan algorithm.">CUDPPScanPlan</a> object containing scan options and intermediate storage </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga98079b338b2af21016a5cba9e00a0eb6"></a><!-- doxytag: member="tridiagonal_app.cu::crpcr" ref="ga98079b338b2af21016a5cba9e00a0eb6" args="(T *d_a, T *d_b, T *d_c, T *d_d, T *d_x, unsigned int systemSizeOriginal, unsigned int numSystems)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void crpcr </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>systemSizeOriginal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>numSystems</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Hybrid CR-PCR solver (CRPCR) </p>
<p>This is a wrapper function for the GPU CR-PCR kernel.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_x</td><td>Solution vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_a</td><td>Lower diagonal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_b</td><td>Main diagonal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_c</td><td>Upper diagonal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_d</td><td>Right hand side </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">systemSizeOriginal</td><td>The size of the linear system </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numSystems</td><td>The number of systems to be solved </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0509ed92fe9640a9d7ea1ce9cfa639d3"></a><!-- doxytag: member="tridiagonal_app.cu::cudppTridiagonalDispatch" ref="ga0509ed92fe9640a9d7ea1ce9cfa639d3" args="(void *d_a, void *d_b, void *d_c, void *d_d, void *d_x, int systemSize, int numSystems, const CUDPPTridiagonalPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppTridiagonalDispatch </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>systemSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numSystems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_u_d_p_p_tridiagonal_plan.html">CUDPPTridiagonalPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dispatches the tridiagonal function based on the plan. </p>
<p>This is the dispatch call for the tridiagonal solver in either float or double datatype.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_x</td><td>Solution vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_a</td><td>Lower diagonal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_b</td><td>Main diagonal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_c</td><td>Upper diagonal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_d</td><td>Right hand side </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">systemSize</td><td>The size of the linear system </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numSystems</td><td>The number of systems to be solved </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>pointer to <a class="el" href="class_c_u_d_p_p_tridiagonal_plan.html" title="Plan class for tridiagonal solver.">CUDPPTridiagonalPlan</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>CUDPPResult indicating success or error condition </dd></dl>

</div>
</div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Tue Aug 9 2011 11:59:20 for CUDPP by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
