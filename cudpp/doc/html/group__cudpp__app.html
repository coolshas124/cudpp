<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>CUDPP: CUDPP Application-Level API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CUDPP&#160;<span id="projectnumber">1.1</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>CUDPP Application-Level API</h1>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="member-group"></a>
Compact Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga6330d24384786e65158a2fc35f05ae9b">calculatCompactLaunchParams</a> (const unsigned int numElements, unsigned int &amp;numThreads, unsigned int &amp;numBlocks, unsigned int &amp;numEltsPerBlock)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate launch parameters for <a class="el" href="group__cudpp__app.html#ga00003db78fb8a269263a5e1205257f40" title="Compact the non-zero elements of an array.">compactArray()</a>.  <a href="#ga6330d24384786e65158a2fc35f05ae9b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga00003db78fb8a269263a5e1205257f40">compactArray</a> (T *d_out, size_t *d_numValidElements, const T *d_in, const unsigned int *d_isValid, size_t numElements, const <a class="el" href="class_c_u_d_p_p_compact_plan.html">CUDPPCompactPlan</a> *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compact the non-zero elements of an array.  <a href="#ga00003db78fb8a269263a5e1205257f40"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#gae84f008f74af507fb9da9568ee22bd21">allocCompactStorage</a> (<a class="el" href="class_c_u_d_p_p_compact_plan.html">CUDPPCompactPlan</a> *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate intermediate arrays used by <a class="el" href="group__public_interface.html#gab3fd0152a8e5b1860b1b7b09a3753ae0" title="Given an array d_in and an array of 1/0 flags in deviceValid, returns a compacted array in d_out of c...">cudppCompact()</a>.  <a href="#gae84f008f74af507fb9da9568ee22bd21"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga5f6b8e696bb6ec4d87d55046041dfb9e">freeCompactStorage</a> (<a class="el" href="class_c_u_d_p_p_compact_plan.html">CUDPPCompactPlan</a> *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate intermediate storage used by <a class="el" href="group__public_interface.html#gab3fd0152a8e5b1860b1b7b09a3753ae0" title="Given an array d_in and an array of 1/0 flags in deviceValid, returns a compacted array in d_out of c...">cudppCompact()</a>.  <a href="#ga5f6b8e696bb6ec4d87d55046041dfb9e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#gafccd7f148a985a1ec19b30cf1d00fdbf">cudppCompactDispatch</a> (void *d_out, size_t *d_numValidElements, const void *d_in, const unsigned int *d_isValid, size_t numElements, const <a class="el" href="class_c_u_d_p_p_compact_plan.html">CUDPPCompactPlan</a> *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch compactArray for the specified datatype.  <a href="#gafccd7f148a985a1ec19b30cf1d00fdbf"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
RadixSort Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga91ad9478d81a7aaf2593e8d9c3d06a14"></a><!-- doxytag: member="cudpp_app::uint" ref="ga91ad9478d81a7aaf2593e8d9c3d06a14" args="" -->
typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>uint</b></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;uint nbits, uint startbit, bool flip, bool unflip&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga77e7cdc13117bec8e3fac63ed506167d">radixSortStep</a> (uint *keys, uint *values, const CUDPPRadixSortPlan *plan, uint numElements)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform one step of the radix sort. Sorts by nbits key bits per step, starting at startbit.  <a href="#ga77e7cdc13117bec8e3fac63ed506167d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;bool flip&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#gaebe1791eec0e357c303bb2d9ec4b36ec">radixSortSingleBlock</a> (uint *keys, uint *values, uint numElements)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Single-block optimization for sorts of fewer than 4 * CTA_SIZE elements.  <a href="#gaebe1791eec0e357c303bb2d9ec4b36ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#gab1667f9693c8cab1d7315a6d00d540a4">radixSort</a> (uint *keys, uint *values, const CUDPPRadixSortPlan *plan, size_t numElements, bool flipBits, int keyBits)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Main radix sort function.  <a href="#gab1667f9693c8cab1d7315a6d00d540a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga52d64ec8e0a8f5271b2903dc9bdcc93e">radixSortFloatKeys</a> (float *keys, uint *values, const CUDPPRadixSortPlan *plan, size_t numElements, bool negativeKeys, int keyBits)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to call main radix sort function. For float configuration.  <a href="#ga52d64ec8e0a8f5271b2903dc9bdcc93e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;uint nbits, uint startbit, bool flip, bool unflip&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga3a2cf76508f6e445da5a39d7fdb56dc7">radixSortStepKeysOnly</a> (uint *keys, const CUDPPRadixSortPlan *plan, uint numElements)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform one step of the radix sort. Sorts by nbits key bits per step, starting at startbit.  <a href="#ga3a2cf76508f6e445da5a39d7fdb56dc7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;bool flip&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#gadfedbe21b41fd7e5689a629b8c82515e">radixSortSingleBlockKeysOnly</a> (uint *keys, uint numElements)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimization for sorts of fewer than 4 * CTA_SIZE elements (keys only).  <a href="#gadfedbe21b41fd7e5689a629b8c82515e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#gad42cebacdd9cbf66bc7f2ca09c234df2">radixSortKeysOnly</a> (uint *keys, const CUDPPRadixSortPlan *plan, size_t numElements, bool flipBits, int keyBits)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Main radix sort function. For keys only configuration.  <a href="#gad42cebacdd9cbf66bc7f2ca09c234df2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#gab003f173dd75e33e59c7a381c6f8696e">radixSortFloatKeysOnly</a> (float *keys, const CUDPPRadixSortPlan *plan, size_t numElements, bool negativeKeys, int keyBits)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to call main radix sort function. For floats and keys only.  <a href="#gab003f173dd75e33e59c7a381c6f8696e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafa31e4e3aeb95d0ece7a6036afb1e577"></a><!-- doxytag: member="cudpp_app::initDeviceParameters" ref="gafa31e4e3aeb95d0ece7a6036afb1e577" args="(CUDPPRadixSortPlan *plan)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>initDeviceParameters</b> (CUDPPRadixSortPlan *plan)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#gaa6043ddac717a99c471bb3dc0fc3c0de">allocRadixSortStorage</a> (CUDPPRadixSortPlan *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">From the programmer-specified sort configuration, creates internal memory for performing the sort.  <a href="#gaa6043ddac717a99c471bb3dc0fc3c0de"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga5b103658becc8dbb8c5ca1026ff61598">freeRadixSortStorage</a> (CUDPPRadixSortPlan *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocates intermediate memory from allocRadixSortStorage.  <a href="#ga5b103658becc8dbb8c5ca1026ff61598"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#gaf0bcb604392916df89c08bef52718dd3">cudppRadixSortDispatch</a> (void *keys, void *values, size_t numElements, int keyBits, const CUDPPRadixSortPlan *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch function to perform a sort on an array with a specified configuration.  <a href="#gaf0bcb604392916df89c08bef52718dd3"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Scan Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , bool isBackward, bool isExclusive, class Op &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#gaab8062495149d43064e1f03b4a8f15f9">scanArrayRecursive</a> (T *d_out, const T *d_in, T **d_blockSums, size_t numElements, size_t numRows, const size_t *rowPitches, int level)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform recursive scan on arbitrary size arrays.  <a href="#gaab8062495149d43064e1f03b4a8f15f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga344e15dee4b3b2351c40bd9cc732bed6">allocScanStorage</a> (<a class="el" href="class_c_u_d_p_p_scan_plan.html">CUDPPScanPlan</a> *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate intermediate arrays used by scan.  <a href="#ga344e15dee4b3b2351c40bd9cc732bed6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga399f5095b183ad026687fd227802ba5c">freeScanStorage</a> (<a class="el" href="class_c_u_d_p_p_scan_plan.html">CUDPPScanPlan</a> *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate intermediate block sums arrays in a <a class="el" href="class_c_u_d_p_p_scan_plan.html" title="Plan class for scan algorithm.">CUDPPScanPlan</a> object.  <a href="#ga399f5095b183ad026687fd227802ba5c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gaac1d3477c349371d25fe4f4df0007ffc"></a><!-- doxytag: member="cudpp_app::cudppScanDispatchOperator" ref="gaac1d3477c349371d25fe4f4df0007ffc" args="(void *d_out, const void *d_in, size_t numElements, size_t numRows, const CUDPPScanPlan *plan)" -->
template&lt;typename T , bool isBackward, bool isExclusive&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cudppScanDispatchOperator</b> (void *d_out, const void *d_in, size_t numElements, size_t numRows, const <a class="el" href="class_c_u_d_p_p_scan_plan.html">CUDPPScanPlan</a> *plan)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga50b953ee85f7bad7aec405447de288af"></a><!-- doxytag: member="cudpp_app::cudppScanDispatchType" ref="ga50b953ee85f7bad7aec405447de288af" args="(void *d_out, const void *d_in, size_t numElements, size_t numRows, const CUDPPScanPlan *plan)" -->
template&lt;bool isBackward, bool isExclusive&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cudppScanDispatchType</b> (void *d_out, const void *d_in, size_t numElements, size_t numRows, const <a class="el" href="class_c_u_d_p_p_scan_plan.html">CUDPPScanPlan</a> *plan)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cudpp__app.html#ga49485cb95e21695293a9c35f8355336d">cudppScanDispatch</a> (void *d_out, const void *d_in, size_t numElements, size_t numRows, const <a class="el" href="class_c_u_d_p_p_scan_plan.html">CUDPPScanPlan</a> *plan)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch function to perform a scan (prefix sum) on an array with the specified configuration.  <a href="#ga49485cb95e21695293a9c35f8355336d"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>The CUDPP Application-Level API contains functions that run on the host CPU and invoke GPU routines in the CUDPP <a class="el" href="group__cudpp__kernel.html">Kernel-Level API</a>. Application-Level API functions are used by CUDPP <a class="el" href="group__public_interface.html">Public Interface</a> functions to implement CUDPP's core functionality. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga6330d24384786e65158a2fc35f05ae9b"></a><!-- doxytag: member="compact_app.cu::calculatCompactLaunchParams" ref="ga6330d24384786e65158a2fc35f05ae9b" args="(const unsigned int numElements, unsigned int &amp;numThreads, unsigned int &amp;numBlocks, unsigned int &amp;numEltsPerBlock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void calculatCompactLaunchParams </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>numThreads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>numBlocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>numEltsPerBlock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate launch parameters for <a class="el" href="group__cudpp__app.html#ga00003db78fb8a269263a5e1205257f40" title="Compact the non-zero elements of an array.">compactArray()</a>. </p>
<p>Calculates the block size and number of blocks from the total number of elements and the maximum threads per block. Called by <a class="el" href="group__cudpp__app.html#ga00003db78fb8a269263a5e1205257f40" title="Compact the non-zero elements of an array.">compactArray()</a>.</p>
<p>The calculation is pretty straightforward - the number of blocks is calculated by dividing the number of input elements by the product of the number of threads in each CTA and the number of elements each thread will process. numThreads and numEltsPerBlock are also simple to calculate. Please note that in cases where numElements is not an exact multiple of SCAN_ELTS_PER_THREAD * CTA_SIZE we would have threads which do nothing or have a thread which will process less than SCAN_ELTS_PER_THREAD elements.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of elements to sort </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">numThreads</td><td>Number of threads in each block </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">numBlocks</td><td>Number of blocks </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">numEltsPerBlock</td><td>Number of elements processed per block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga00003db78fb8a269263a5e1205257f40"></a><!-- doxytag: member="compact_app.cu::compactArray" ref="ga00003db78fb8a269263a5e1205257f40" args="(T *d_out, size_t *d_numValidElements, const T *d_in, const unsigned int *d_isValid, size_t numElements, const CUDPPCompactPlan *plan)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void compactArray </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>d_numValidElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>d_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>d_isValid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_u_d_p_p_compact_plan.html">CUDPPCompactPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compact the non-zero elements of an array. </p>
<p>Given an input array <em>d_in</em>, <a class="el" href="group__cudpp__app.html#ga00003db78fb8a269263a5e1205257f40" title="Compact the non-zero elements of an array.">compactArray()</a> outputs a compacted version which does not have null (zero) elements. Also ouputs the number of non-zero elements in the compacted array. Called by <a class="el" href="group__cudpp__app.html#gafccd7f148a985a1ec19b30cf1d00fdbf" title="Dispatch compactArray for the specified datatype.">cudppCompactDispatch()</a>.</p>
<p>The algorithm is straightforward, involving two steps (most of the complexity is hidden in scan, invoked with <a class="el" href="group__cudpp__app.html#ga49485cb95e21695293a9c35f8355336d" title="Dispatch function to perform a scan (prefix sum) on an array with the specified configuration.">cudppScanDispatch()</a> ).</p>
<ol type="1">
<li>scanArray() performs a prefix sum on <em>d_isValid</em> to compute output indices.</li>
<li><a class="el" href="group__cudpp__kernel.html#ga02aca9cfcac6799d445c857626e7d317" title="Consolidate non-null elements - for each non-null element in d_in write it to d_out, in the position specified by d_isValid. Called by compactArray().">compactData()</a> takes <em>d_in</em> and an intermediate array of output indices as input and writes the values with valid flags in <em>d_isValid</em> into <em>d_out</em> using the output indices.</li>
</ol>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_out</td><td>Array of compacted non-null elements </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_numValidElements</td><td>Pointer to unsigned int to store number of non-null elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_in</td><td>Input array </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_isValid</td><td>Array of flags, 1 for each non-null element, 0 for each null element. Same length as <em>d_in</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of elements in input array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to the plan object used for this compact </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae84f008f74af507fb9da9568ee22bd21"></a><!-- doxytag: member="compact_app.cu::allocCompactStorage" ref="gae84f008f74af507fb9da9568ee22bd21" args="(CUDPPCompactPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void allocCompactStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_u_d_p_p_compact_plan.html">CUDPPCompactPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate intermediate arrays used by <a class="el" href="group__public_interface.html#gab3fd0152a8e5b1860b1b7b09a3753ae0" title="Given an array d_in and an array of 1/0 flags in deviceValid, returns a compacted array in d_out of c...">cudppCompact()</a>. </p>
<p>In addition to the internal <a class="el" href="class_c_u_d_p_p_scan_plan.html" title="Plan class for scan algorithm.">CUDPPScanPlan</a> contained in <a class="el" href="class_c_u_d_p_p_compact_plan.html" title="Plan class for compact algorithm.">CUDPPCompactPlan</a>, CUDPPCompact also needs a temporary device array of output indices, which is allocated by this function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_compact_plan.html" title="Plan class for compact algorithm.">CUDPPCompactPlan</a> object within which intermediate storage is allocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5f6b8e696bb6ec4d87d55046041dfb9e"></a><!-- doxytag: member="compact_app.cu::freeCompactStorage" ref="ga5f6b8e696bb6ec4d87d55046041dfb9e" args="(CUDPPCompactPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freeCompactStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_u_d_p_p_compact_plan.html">CUDPPCompactPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deallocate intermediate storage used by <a class="el" href="group__public_interface.html#gab3fd0152a8e5b1860b1b7b09a3753ae0" title="Given an array d_in and an array of 1/0 flags in deviceValid, returns a compacted array in d_out of c...">cudppCompact()</a>. </p>
<p>Deallocates the output indices array allocated by <a class="el" href="group__cudpp__app.html#gae84f008f74af507fb9da9568ee22bd21" title="Allocate intermediate arrays used by cudppCompact().">allocCompactStorage()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_compact_plan.html" title="Plan class for compact algorithm.">CUDPPCompactPlan</a> object initialized by <a class="el" href="group__cudpp__app.html#gae84f008f74af507fb9da9568ee22bd21" title="Allocate intermediate arrays used by cudppCompact().">allocCompactStorage()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafccd7f148a985a1ec19b30cf1d00fdbf"></a><!-- doxytag: member="compact_app.cu::cudppCompactDispatch" ref="gafccd7f148a985a1ec19b30cf1d00fdbf" args="(void *d_out, size_t *d_numValidElements, const void *d_in, const unsigned int *d_isValid, size_t numElements, const CUDPPCompactPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudppCompactDispatch </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>d_numValidElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>d_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>d_isValid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_u_d_p_p_compact_plan.html">CUDPPCompactPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dispatch compactArray for the specified datatype. </p>
<p>A thin wrapper on top of compactArray which calls <a class="el" href="group__cudpp__app.html#ga00003db78fb8a269263a5e1205257f40" title="Compact the non-zero elements of an array.">compactArray()</a> for the data type specified in <em>config</em>. This is the app-level interface to compact used by <a class="el" href="group__public_interface.html#gab3fd0152a8e5b1860b1b7b09a3753ae0" title="Given an array d_in and an array of 1/0 flags in deviceValid, returns a compacted array in d_out of c...">cudppCompact()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_out</td><td>Compacted array of non-zero elements </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_numValidElements</td><td>Pointer to an unsigned int to store the number of non-zero elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_in</td><td>Input array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_isValid</td><td>Array of boolean valid flags with same length as <em>d_in</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of elements to compact </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to plan object for this compact </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga77e7cdc13117bec8e3fac63ed506167d"></a><!-- doxytag: member="radixsort_app.cu::radixSortStep" ref="ga77e7cdc13117bec8e3fac63ed506167d" args="(uint *keys, uint *values, const CUDPPRadixSortPlan *plan, uint numElements)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint nbits, uint startbit, bool flip, bool unflip&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void radixSortStep </td>
          <td>(</td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CUDPPRadixSortPlan *&#160;</td>
          <td class="paramname"><em>plan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform one step of the radix sort. Sorts by nbits key bits per step, starting at startbit. </p>
<p>Uses <a class="el" href="group__cudpp__app.html#ga49485cb95e21695293a9c35f8355336d" title="Dispatch function to perform a scan (prefix sum) on an array with the specified configuration.">cudppScanDispatch()</a> for the prefix sum of radix counters.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">keys</td><td>Keys to be sorted. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">values</td><td>Associated values to be sorted (through keys). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Configuration information for RadixSort. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of elements in the sort. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaebe1791eec0e357c303bb2d9ec4b36ec"></a><!-- doxytag: member="radixsort_app.cu::radixSortSingleBlock" ref="gaebe1791eec0e357c303bb2d9ec4b36ec" args="(uint *keys, uint *values, uint numElements)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool flip&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void radixSortSingleBlock </td>
          <td>(</td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Single-block optimization for sorts of fewer than 4 * CTA_SIZE elements. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">keys</td><td>Keys to be sorted. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">values</td><td>Associated values to be sorted (through keys). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">numElements</td><td>Number of elements in the sort. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab1667f9693c8cab1d7315a6d00d540a4"></a><!-- doxytag: member="radixsort_app.cu::radixSort" ref="gab1667f9693c8cab1d7315a6d00d540a4" args="(uint *keys, uint *values, const CUDPPRadixSortPlan *plan, size_t numElements, bool flipBits, int keyBits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void radixSort </td>
          <td>(</td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CUDPPRadixSortPlan *&#160;</td>
          <td class="paramname"><em>plan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flipBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>keyBits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Main radix sort function. </p>
<p>Main radix sort function. Sorts in place in the keys and values arrays, but uses the other device arrays as temporary storage. All pointer parameters are device pointers. Uses <a class="el" href="group__public_interface.html#ga19f4711b5219ff1fd4851fda0398d547" title="Performs a scan operation of numElements on its input in GPU memory (d_in) and places the output in G...">cudppScan()</a> for the prefix sum of radix counters.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">keys</td><td>Keys to be sorted. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">values</td><td>Associated values to be sorted (through keys). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Configuration information for RadixSort. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of elements in the sort. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flipBits</td><td>Is set true if key datatype is a float (neg. numbers) for special float sorting operations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keyBits</td><td>Number of interesting bits in the key </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga52d64ec8e0a8f5271b2903dc9bdcc93e"></a><!-- doxytag: member="radixsort_app.cu::radixSortFloatKeys" ref="ga52d64ec8e0a8f5271b2903dc9bdcc93e" args="(float *keys, uint *values, const CUDPPRadixSortPlan *plan, size_t numElements, bool negativeKeys, int keyBits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void radixSortFloatKeys </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CUDPPRadixSortPlan *&#160;</td>
          <td class="paramname"><em>plan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>negativeKeys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>keyBits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wrapper to call main radix sort function. For float configuration. </p>
<p>Calls the main radix sort function. For float configuration.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">keys</td><td>Keys to be sorted. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">values</td><td>Associated values to be sorted (through keys). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Configuration information for RadixSort. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of elements in the sort. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">negativeKeys</td><td>Is set true if key datatype has neg. numbers. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keyBits</td><td>Number of interesting bits in the key </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3a2cf76508f6e445da5a39d7fdb56dc7"></a><!-- doxytag: member="radixsort_app.cu::radixSortStepKeysOnly" ref="ga3a2cf76508f6e445da5a39d7fdb56dc7" args="(uint *keys, const CUDPPRadixSortPlan *plan, uint numElements)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;uint nbits, uint startbit, bool flip, bool unflip&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void radixSortStepKeysOnly </td>
          <td>(</td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CUDPPRadixSortPlan *&#160;</td>
          <td class="paramname"><em>plan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform one step of the radix sort. Sorts by nbits key bits per step, starting at startbit. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">keys</td><td>Keys to be sorted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Configuration information for RadixSort. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of elements in the sort. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadfedbe21b41fd7e5689a629b8c82515e"></a><!-- doxytag: member="radixsort_app.cu::radixSortSingleBlockKeysOnly" ref="gadfedbe21b41fd7e5689a629b8c82515e" args="(uint *keys, uint numElements)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool flip&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void radixSortSingleBlockKeysOnly </td>
          <td>(</td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Optimization for sorts of fewer than 4 * CTA_SIZE elements (keys only). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">keys</td><td>Keys to be sorted. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">numElements</td><td>Number of elements in the sort. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad42cebacdd9cbf66bc7f2ca09c234df2"></a><!-- doxytag: member="radixsort_app.cu::radixSortKeysOnly" ref="gad42cebacdd9cbf66bc7f2ca09c234df2" args="(uint *keys, const CUDPPRadixSortPlan *plan, size_t numElements, bool flipBits, int keyBits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void radixSortKeysOnly </td>
          <td>(</td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CUDPPRadixSortPlan *&#160;</td>
          <td class="paramname"><em>plan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flipBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>keyBits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Main radix sort function. For keys only configuration. </p>
<p>Main radix sort function. Sorts in place in the keys array, but uses the other device arrays as temporary storage. All pointer parameters are device pointers. Uses scan for the prefix sum of radix counters.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">keys</td><td>Keys to be sorted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Configuration information for RadixSort. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flipBits</td><td>Is set true if key datatype is a float (neg. numbers) for special float sorting operations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of elements in the sort. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keyBits</td><td>Number of interesting bits in the key </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab003f173dd75e33e59c7a381c6f8696e"></a><!-- doxytag: member="radixsort_app.cu::radixSortFloatKeysOnly" ref="gab003f173dd75e33e59c7a381c6f8696e" args="(float *keys, const CUDPPRadixSortPlan *plan, size_t numElements, bool negativeKeys, int keyBits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void radixSortFloatKeysOnly </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CUDPPRadixSortPlan *&#160;</td>
          <td class="paramname"><em>plan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>negativeKeys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>keyBits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wrapper to call main radix sort function. For floats and keys only. </p>
<p>Calls the radixSortKeysOnly function setting parameters for floats.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">keys</td><td>Keys to be sorted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Configuration information for RadixSort. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">negativeKeys</td><td>Is set true if key flipBits is to be true in <a class="el" href="group__cudpp__app.html#gad42cebacdd9cbf66bc7f2ca09c234df2" title="Main radix sort function. For keys only configuration.">radixSortKeysOnly()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of elements in the sort. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keyBits</td><td>Number of interesting bits in the key </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa6043ddac717a99c471bb3dc0fc3c0de"></a><!-- doxytag: member="radixsort_app.cu::allocRadixSortStorage" ref="gaa6043ddac717a99c471bb3dc0fc3c0de" args="(CUDPPRadixSortPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void allocRadixSortStorage </td>
          <td>(</td>
          <td class="paramtype">CUDPPRadixSortPlan *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>From the programmer-specified sort configuration, creates internal memory for performing the sort. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to CUDPPRadixSortPlan object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5b103658becc8dbb8c5ca1026ff61598"></a><!-- doxytag: member="radixsort_app.cu::freeRadixSortStorage" ref="ga5b103658becc8dbb8c5ca1026ff61598" args="(CUDPPRadixSortPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freeRadixSortStorage </td>
          <td>(</td>
          <td class="paramtype">CUDPPRadixSortPlan *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deallocates intermediate memory from allocRadixSortStorage. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to CUDPPRadixSortPlan object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf0bcb604392916df89c08bef52718dd3"></a><!-- doxytag: member="radixsort_app.cu::cudppRadixSortDispatch" ref="gaf0bcb604392916df89c08bef52718dd3" args="(void *keys, void *values, size_t numElements, int keyBits, const CUDPPRadixSortPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudppRadixSortDispatch </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>keyBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CUDPPRadixSortPlan *&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dispatch function to perform a sort on an array with a specified configuration. </p>
<p>This is the dispatch routine which calls radixSort...() with appropriate template parameters and arguments as specified by the plan. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">keys</td><td>Keys to be sorted. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">values</td><td>Associated values to be sorted (through keys). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>Number of elements in the sort. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keyBits</td><td>Number of interesting bits in the key* </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Configuration information for RadixSort. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaab8062495149d43064e1f03b4a8f15f9"></a><!-- doxytag: member="scan_app.cu::scanArrayRecursive" ref="gaab8062495149d43064e1f03b4a8f15f9" args="(T *d_out, const T *d_in, T **d_blockSums, size_t numElements, size_t numRows, const size_t *rowPitches, int level)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , bool isBackward, bool isExclusive, class Op &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void scanArrayRecursive </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>d_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T **&#160;</td>
          <td class="paramname"><em>d_blockSums</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>rowPitches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform recursive scan on arbitrary size arrays. </p>
<p>This is the CPU-side workhorse function of the scan engine. This function invokes the CUDA kernels which perform the scan on individual blocks.</p>
<p>Scans of large arrays must be split (possibly recursively) into a hierarchy of block scans, where each block is scanned by a single CUDA thread block. At each recursive level of the scanArrayRecursive first invokes a kernel to scan all blocks of that level, and if the level has more than one block, it calls itself recursively. On returning from each recursive level, the total sum of each block from the level below is added to all elements of the corresponding block in this level. See "Parallel Prefix Sum (Scan) in CUDA" for more information (see <a class="el" href="index.html#references">References</a> ).</p>
<p>Template parameter <em>T</em> is the datatype; <em>isBackward</em> specifies backward or forward scan; <em>isExclusive</em> specifies exclusive or inclusive scan, and <em>op</em> specifies the binary associative operator to be used.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_out</td><td>The output array for the scan results </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_in</td><td>The input array to be scanned </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_blockSums</td><td>Array of arrays of per-block sums (one array per recursive level, allocated by <a class="el" href="group__cudpp__app.html#ga344e15dee4b3b2351c40bd9cc732bed6" title="Allocate intermediate arrays used by scan.">allocScanStorage()</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>The number of elements in the array to scan </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numRows</td><td>The number of rows in the array to scan </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rowPitches</td><td>Array of row pitches (one array per recursive level, allocated by <a class="el" href="group__cudpp__app.html#ga344e15dee4b3b2351c40bd9cc732bed6" title="Allocate intermediate arrays used by scan.">allocScanStorage()</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>The current recursive level of the scan </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga344e15dee4b3b2351c40bd9cc732bed6"></a><!-- doxytag: member="scan_app.cu::allocScanStorage" ref="ga344e15dee4b3b2351c40bd9cc732bed6" args="(CUDPPScanPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void allocScanStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_u_d_p_p_scan_plan.html">CUDPPScanPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate intermediate arrays used by scan. </p>
<p>Scans of large arrays must be split (possibly recursively) into a hierarchy of block scans, where each block is scanned by a single CUDA thread block. At each recursive level of the scan, we need an array in which to store the total sums of all blocks in that level. This function computes the amount of storage needed and allocates it.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_scan_plan.html" title="Plan class for scan algorithm.">CUDPPScanPlan</a> object containing options and number of elements, which is used to compute storage requirements, and within which intermediate storage is allocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga399f5095b183ad026687fd227802ba5c"></a><!-- doxytag: member="scan_app.cu::freeScanStorage" ref="ga399f5095b183ad026687fd227802ba5c" args="(CUDPPScanPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freeScanStorage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_c_u_d_p_p_scan_plan.html">CUDPPScanPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deallocate intermediate block sums arrays in a <a class="el" href="class_c_u_d_p_p_scan_plan.html" title="Plan class for scan algorithm.">CUDPPScanPlan</a> object. </p>
<p>These arrays must have been allocated by <a class="el" href="group__cudpp__app.html#ga344e15dee4b3b2351c40bd9cc732bed6" title="Allocate intermediate arrays used by scan.">allocScanStorage()</a>, which is called by the constructor of cudppScanPlan().</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_scan_plan.html" title="Plan class for scan algorithm.">CUDPPScanPlan</a> object initialized by <a class="el" href="group__cudpp__app.html#ga344e15dee4b3b2351c40bd9cc732bed6" title="Allocate intermediate arrays used by scan.">allocScanStorage()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga49485cb95e21695293a9c35f8355336d"></a><!-- doxytag: member="scan_app.cu::cudppScanDispatch" ref="ga49485cb95e21695293a9c35f8355336d" args="(void *d_out, const void *d_in, size_t numElements, size_t numRows, const CUDPPScanPlan *plan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cudppScanDispatch </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>d_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_u_d_p_p_scan_plan.html">CUDPPScanPlan</a> *&#160;</td>
          <td class="paramname"><em>plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dispatch function to perform a scan (prefix sum) on an array with the specified configuration. </p>
<p>This is the dispatch routine which calls <a class="el" href="group__cudpp__app.html#gaab8062495149d43064e1f03b4a8f15f9" title="Perform recursive scan on arbitrary size arrays.">scanArrayRecursive()</a> with appropriate template parameters and arguments to achieve the scan as specified in <em>plan</em>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">d_out</td><td>The output array of scan results </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_in</td><td>The input array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>The number of elements to scan </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numRows</td><td>The number of rows to scan in parallel </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">plan</td><td>Pointer to <a class="el" href="class_c_u_d_p_p_scan_plan.html" title="Plan class for scan algorithm.">CUDPPScanPlan</a> object containing scan options and intermediate storage </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Wed Feb 16 2011 16:10:07 for CUDPP by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
