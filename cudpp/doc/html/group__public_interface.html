<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>CUDPP: CUDPP Public Interface</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CUDPP&#160;<span id="projectnumber">1.1</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>CUDPP Public Interface</h1>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#ga9156a26943f99d0fff44d218129631b4">cudppCreate</a> (CUDPPHandle *theCudpp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of the CUDPP library, and returns a handle.  <a href="#ga9156a26943f99d0fff44d218129631b4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#ga8b98b05d585860ec4fcc44472244d01b">cudppDestroy</a> (CUDPPHandle theCudpp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys an instance of the CUDPP library given its handle.  <a href="#ga8b98b05d585860ec4fcc44472244d01b"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Algorithm Interface</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#ga19f4711b5219ff1fd4851fda0398d547">cudppScan</a> (const CUDPPHandle planHandle, void *d_out, const void *d_in, size_t numElements)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a scan operation of numElements on its input in GPU memory (d_in) and places the output in GPU memory (d_out), with the scan parameters specified in the plan pointed to by planHandle.  <a href="#ga19f4711b5219ff1fd4851fda0398d547"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#gaf71eb423ec3252ca122e5c01b055fa51">cudppSegmentedScan</a> (const CUDPPHandle planHandle, void *d_out, const void *d_idata, const unsigned int *d_iflags, size_t numElements)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a segmented scan operation of numElements on its input in GPU memory (d_idata) and places the output in GPU memory (d_out), with the scan parameters specified in the plan pointed to by planHandle.  <a href="#gaf71eb423ec3252ca122e5c01b055fa51"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#gad9655b51dba16bc43b8adee4507dc1d0">cudppMultiScan</a> (const CUDPPHandle planHandle, void *d_out, const void *d_in, size_t numElements, size_t numRows)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs numRows parallel scan operations of numElements each on its input (d_in) and places the output in d_out, with the scan parameters set by config. Exactly like cudppScan except that it runs on multiple rows in parallel.  <a href="#gad9655b51dba16bc43b8adee4507dc1d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#gab3fd0152a8e5b1860b1b7b09a3753ae0">cudppCompact</a> (const CUDPPHandle planHandle, void *d_out, size_t *d_numValidElements, const void *d_in, const unsigned int *d_isValid, size_t numElements)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an array <em>d_in</em> and an array of 1/0 flags in <em>deviceValid</em>, returns a compacted array in <em>d_out</em> of corresponding only the "valid" values from <em>d_in</em>.  <a href="#gab3fd0152a8e5b1860b1b7b09a3753ae0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#ga21d9b2b3c74daffbec52ef628f835313">cudppReduce</a> (const CUDPPHandle planHandle, void *d_out, const void *d_in, size_t numElements)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduces an array to a single element using a binary associative operator.  <a href="#ga21d9b2b3c74daffbec52ef628f835313"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#ga9e1be7178f575d5ca7c028b389cd4cf3">cudppSort</a> (const CUDPPHandle planHandle, void *d_keys, void *d_values, int keyBits, size_t numElements)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts key-value pairs or keys only.  <a href="#ga9e1be7178f575d5ca7c028b389cd4cf3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#gaeedaa3a7ec8bbd6770c6fbce3c4276c5">cudppSparseMatrixVectorMultiply</a> (const CUDPPHandle sparseMatrixHandle, void *d_y, const void *d_x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform matrix-vector multiply y = A*x for arbitrary sparse matrix A and vector x.  <a href="#gaeedaa3a7ec8bbd6770c6fbce3c4276c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#gac27c987891faceedf79598f744212c67">cudppRand</a> (const CUDPPHandle planHandle, void *d_out, size_t numElements)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Rand puts <em>numElements</em> random 32-bit elements into <em>d_out</em>.  <a href="#gac27c987891faceedf79598f744212c67"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#ga9120af9942d2553d2f376ede0f7079dd">cudppRandSeed</a> (const CUDPPHandle planHandle, unsigned int seed)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the seed used for rand.  <a href="#ga9120af9942d2553d2f376ede0f7079dd"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Plan Interface</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#ga31fd56135f9c8f73da79af83a958f27c">cudppPlan</a> (const CUDPPHandle cudppHandle, CUDPPHandle *planHandle, <a class="el" href="struct_c_u_d_p_p_configuration.html">CUDPPConfiguration</a> config, size_t numElements, size_t numRows, size_t rowPitch)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a CUDPP plan.  <a href="#ga31fd56135f9c8f73da79af83a958f27c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#ga4015898886e140ad95f320ab4c07db2c">cudppDestroyPlan</a> (CUDPPHandle planHandle)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a CUDPP Plan.  <a href="#ga4015898886e140ad95f320ab4c07db2c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#gabc6c2587fe06dadd93fb1d69ba836d84">cudppSparseMatrix</a> (const CUDPPHandle cudppHandle, CUDPPHandle *sparseMatrixHandle, <a class="el" href="struct_c_u_d_p_p_configuration.html">CUDPPConfiguration</a> config, size_t numNonZeroElements, size_t numRows, const void *A, const unsigned int *h_rowIndices, const unsigned int *h_indices)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a CUDPP Sparse Matrix Object.  <a href="#gabc6c2587fe06dadd93fb1d69ba836d84"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__public_interface.html#gae0644c758120abaef0e2bb396f57cefb">cudppDestroySparseMatrix</a> (CUDPPHandle sparseMatrixHandle)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a CUDPP Sparse Matrix Object.  <a href="#gae0644c758120abaef0e2bb396f57cefb"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>The CUDA public interface comprises the functions, structs, and enums defined in <a class="el" href="cudpp_8h.html" title="Main library header file. Defines public interface.">cudpp.h</a>. Public interface functions call functions in the <a class="el" href="group__cudpp__app.html">Application-Level</a> interface. The public interface functions include Plan Interface functions and Algorithm Interface functions. Plan Inteface functions are used for creating CUDPP Plan objects which contain configuration details, intermediate storage space, and in the case of <a class="el" href="group__public_interface.html#gabc6c2587fe06dadd93fb1d69ba836d84" title="Create a CUDPP Sparse Matrix Object.">cudppSparseMatrix()</a>, data. The Algorithm Interface is the set of functions that do the real work of CUDPP, such as <a class="el" href="group__public_interface.html#ga19f4711b5219ff1fd4851fda0398d547" title="Performs a scan operation of numElements on its input in GPU memory (d_in) and places the output in G...">cudppScan()</a> and cudppSparseMatrixVectorMultiply. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga19f4711b5219ff1fd4851fda0398d547"></a><!-- doxytag: member="cudpp.cpp::cudppScan" ref="ga19f4711b5219ff1fd4851fda0398d547" args="(const CUDPPHandle planHandle, void *d_out, const void *d_in, size_t numElements)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppScan </td>
          <td>(</td>
          <td class="paramtype">const CUDPPHandle&#160;</td>
          <td class="paramname"><em>planHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>d_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs a scan operation of numElements on its input in GPU memory (d_in) and places the output in GPU memory (d_out), with the scan parameters specified in the plan pointed to by planHandle. </p>
<p>The input to a scan operation is an input array, a binary associative operator (like + or max), and an identity element for that operator (+'s identity is 0). The output of scan is the same size as its input. Informally, the output at each element is the result of operator applied to each input that comes before it. For instance, the output of sum-scan at each element is the sum of all the input elements before that input.</p>
<p>More formally, for associative operator  &oplus; , <em>out<sub>i</sub></em> = <em>in<sub>0</sub></em>  &oplus;  <em>in<sub>1</sub></em>  &oplus;  ...  &oplus;  <em>in<sub>i-1</sub></em>.</p>
<p>CUDPP supports "exclusive" and "inclusive" scans. For the ADD operator, an exclusive scan computes the sum of all input elements before the current element, while an inclusive scan computes the sum of all input elements up to and including the current element.</p>
<p>Before calling scan, create an internal plan using <a class="el" href="group__public_interface.html#ga31fd56135f9c8f73da79af83a958f27c" title="Create a CUDPP plan.">cudppPlan()</a>.</p>
<p>After you are finished with the scan plan, clean up with <a class="el" href="group__public_interface.html#ga4015898886e140ad95f320ab4c07db2c" title="Destroy a CUDPP Plan.">cudppDestroyPlan()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">planHandle</td><td>Handle to plan for this scan </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_out</td><td>output of scan, in GPU memory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_in</td><td>input to scan, in GPU memory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>number of elements to scan</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__public_interface.html#ga31fd56135f9c8f73da79af83a958f27c" title="Create a CUDPP plan.">cudppPlan</a>, <a class="el" href="group__public_interface.html#ga4015898886e140ad95f320ab4c07db2c" title="Destroy a CUDPP Plan.">cudppDestroyPlan</a> </dd></dl>

<p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd>Return more specific errors </dd></dl>
</p>

</div>
</div>
<a class="anchor" id="gaf71eb423ec3252ca122e5c01b055fa51"></a><!-- doxytag: member="cudpp.cpp::cudppSegmentedScan" ref="gaf71eb423ec3252ca122e5c01b055fa51" args="(const CUDPPHandle planHandle, void *d_out, const void *d_idata, const unsigned int *d_iflags, size_t numElements)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppSegmentedScan </td>
          <td>(</td>
          <td class="paramtype">const CUDPPHandle&#160;</td>
          <td class="paramname"><em>planHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>d_idata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>d_iflags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs a segmented scan operation of numElements on its input in GPU memory (d_idata) and places the output in GPU memory (d_out), with the scan parameters specified in the plan pointed to by planHandle. </p>
<p>The input to a segmented scan operation is an input array of data, an input array of flags which demarcate segments, a binary associative operator (like + or max), and an identity element for that operator (+'s identity is 0). The array of flags is the same length as the input with 1 marking the the first element of a segment and 0 otherwise. The output of segmented scan is the same size as its input. Informally, the output at each element is the result of operator applied to each input that comes before it in that segment. For instance, the output of segmented sum-scan at each element is the sum of all the input elements before that input in that segment.</p>
<p>More formally, for associative operator  &oplus; , <em>out<sub>i</sub></em> = <em>in<sub>k</sub></em>  &oplus;  <em>in<sub>k+1</sub></em>  &oplus;  ...  &oplus;  <em>in<sub>i-1</sub></em>. <em>k</em> is the index of the first element of the segment in which <em>i</em> lies</p>
<p>We support both "exclusive" and "inclusive" variants. For a segmented sum-scan, the exclusive variant computes the sum of all input elements before the current element in that segment, while the inclusive variant computes the sum of all input elements up to and including the current element, in that segment.</p>
<p>Before calling segmented scan, create an internal plan using <a class="el" href="group__public_interface.html#ga31fd56135f9c8f73da79af83a958f27c" title="Create a CUDPP plan.">cudppPlan()</a>.</p>
<p>After you are finished with the scan plan, clean up with <a class="el" href="group__public_interface.html#ga4015898886e140ad95f320ab4c07db2c" title="Destroy a CUDPP Plan.">cudppDestroyPlan()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">planHandle</td><td>Handle to plan for this scan </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_out</td><td>output of segmented scan, in GPU memory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_idata</td><td>input data to segmented scan, in GPU memory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_iflags</td><td>input flags to segmented scan, in GPU memory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>number of elements to perform segmented scan on</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__public_interface.html#ga31fd56135f9c8f73da79af83a958f27c" title="Create a CUDPP plan.">cudppPlan</a>, <a class="el" href="group__public_interface.html#ga4015898886e140ad95f320ab4c07db2c" title="Destroy a CUDPP Plan.">cudppDestroyPlan</a> </dd></dl>

<p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd>Return more specific errors </dd></dl>
</p>

</div>
</div>
<a class="anchor" id="gad9655b51dba16bc43b8adee4507dc1d0"></a><!-- doxytag: member="cudpp.cpp::cudppMultiScan" ref="gad9655b51dba16bc43b8adee4507dc1d0" args="(const CUDPPHandle planHandle, void *d_out, const void *d_in, size_t numElements, size_t numRows)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppMultiScan </td>
          <td>(</td>
          <td class="paramtype">const CUDPPHandle&#160;</td>
          <td class="paramname"><em>planHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>d_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numRows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs numRows parallel scan operations of numElements each on its input (d_in) and places the output in d_out, with the scan parameters set by config. Exactly like cudppScan except that it runs on multiple rows in parallel. </p>
<p>Note that to achieve good performance with cudppMultiScan one should allocate the device arrays passed to it so that all rows are aligned to the correct boundaries for the architecture the app is running on. The easy way to do this is to use cudaMallocPitch() to allocate a 2D array on the device. Use the <em>rowPitch</em> parameter to <a class="el" href="group__public_interface.html#ga31fd56135f9c8f73da79af83a958f27c" title="Create a CUDPP plan.">cudppPlan()</a> to specify this pitch. The easiest way is to pass the device pitch returned by cudaMallocPitch to <a class="el" href="group__public_interface.html#ga31fd56135f9c8f73da79af83a958f27c" title="Create a CUDPP plan.">cudppPlan()</a> via <em>rowPitch</em>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">planHandle</td><td>handle to <a class="el" href="class_c_u_d_p_p_scan_plan.html" title="Plan class for scan algorithm.">CUDPPScanPlan</a> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_out</td><td>output of scan, in GPU memory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_in</td><td>input to scan, in GPU memory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>number of elements (per row) to scan </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numRows</td><td>number of rows to scan in parallel</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__public_interface.html#ga19f4711b5219ff1fd4851fda0398d547" title="Performs a scan operation of numElements on its input in GPU memory (d_in) and places the output in G...">cudppScan</a>, <a class="el" href="group__public_interface.html#ga31fd56135f9c8f73da79af83a958f27c" title="Create a CUDPP plan.">cudppPlan</a> </dd></dl>

<p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000007">Todo:</a></b></dt><dd>Return more specific errors </dd></dl>
</p>

</div>
</div>
<a class="anchor" id="gab3fd0152a8e5b1860b1b7b09a3753ae0"></a><!-- doxytag: member="cudpp.cpp::cudppCompact" ref="gab3fd0152a8e5b1860b1b7b09a3753ae0" args="(const CUDPPHandle planHandle, void *d_out, size_t *d_numValidElements, const void *d_in, const unsigned int *d_isValid, size_t numElements)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppCompact </td>
          <td>(</td>
          <td class="paramtype">const CUDPPHandle&#160;</td>
          <td class="paramname"><em>planHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>d_numValidElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>d_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>d_isValid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given an array <em>d_in</em> and an array of 1/0 flags in <em>deviceValid</em>, returns a compacted array in <em>d_out</em> of corresponding only the "valid" values from <em>d_in</em>. </p>
<p>Takes as input an array of elements in GPU memory (<em>d_in</em>) and an equal-sized unsigned int array in GPU memory (<em>deviceValid</em>) that indicate which of those input elements are valid. The output is a packed array, in GPU memory, of only those elements marked as valid.</p>
<p>Internally, uses cudppScan.</p>
<p>Example: </p>
<div class="fragment"><pre class="fragment"> d_in    = [ a b c d e f ]
 deviceValid = [ 1 0 1 1 0 1 ]
 d_out   = [ a c d f ]
</pre></div><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000008">Todo:</a></b></dt><dd>[MJH] We need to evaluate whether cudppCompact should be a core member of the public interface. It's not clear to me that what the user always wants is a final compacted array. Often one just wants the array of indices to which each input element should go in the output. The split() routine used in radix sort might make more sense to expose.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">planHandle</td><td>handle to <a class="el" href="class_c_u_d_p_p_compact_plan.html" title="Plan class for compact algorithm.">CUDPPCompactPlan</a> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_out</td><td>compacted output </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_numValidElements</td><td>set during cudppCompact; is set with the number of elements valid flags in the d_isValid input array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_in</td><td>input to compact </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_isValid</td><td>which elements in d_in are valid </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>number of elements in d_in </td></tr>
  </table>
  </dd>
</dl>

<p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000009">Todo:</a></b></dt><dd>Return more specific errors. </dd></dl>
</p>

</div>
</div>
<a class="anchor" id="ga21d9b2b3c74daffbec52ef628f835313"></a><!-- doxytag: member="cudpp.cpp::cudppReduce" ref="ga21d9b2b3c74daffbec52ef628f835313" args="(const CUDPPHandle planHandle, void *d_out, const void *d_in, size_t numElements)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppReduce </td>
          <td>(</td>
          <td class="paramtype">const CUDPPHandle&#160;</td>
          <td class="paramname"><em>planHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>d_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reduces an array to a single element using a binary associative operator. </p>
<p>For example, if the operator is CUDPP_ADD, then: </p>
<div class="fragment"><pre class="fragment"> d_in    = [ 3 2 0 1 -4 5 0 -1 ]
 d_out   = [ 6 ]
</pre></div><p>If the operator is CUDPP_MIN, then: </p>
<div class="fragment"><pre class="fragment"> d_in    = [ 3 2 0 1 -4 5 0 -1 ]
 d_out   = [ -4 ]
</pre></div><p>Limits: <em>numElements</em> must be at least 1, and is currently limited only by the addressable memory in CUDA (and the output accuracy is limited by numerical precision).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">planHandle</td><td>handle to <a class="el" href="class_c_u_d_p_p_reduce_plan.html" title="Plan class for reduce algorithm.">CUDPPReducePlan</a> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_out</td><td>Output of reduce (a single element) in GPU memory. Must be a pointer to an array of at least a single element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_in</td><td>Input array to reduce in GPU memory. Must be a pointer to an array of at least <em>numElements</em> elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>the number of elements to reduce.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__public_interface.html#ga31fd56135f9c8f73da79af83a958f27c" title="Create a CUDPP plan.">cudppPlan</a> </dd></dl>

<p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000010">Todo:</a></b></dt><dd>Return more specific errors. </dd></dl>
</p>

</div>
</div>
<a class="anchor" id="ga9e1be7178f575d5ca7c028b389cd4cf3"></a><!-- doxytag: member="cudpp.cpp::cudppSort" ref="ga9e1be7178f575d5ca7c028b389cd4cf3" args="(const CUDPPHandle planHandle, void *d_keys, void *d_values, int keyBits, size_t numElements)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppSort </td>
          <td>(</td>
          <td class="paramtype">const CUDPPHandle&#160;</td>
          <td class="paramname"><em>planHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>keyBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sorts key-value pairs or keys only. </p>
<p>Takes as input an array of keys in GPU memory (d_keys) and an optional array of corresponding values, and outputs sorted arrays of keys and (optionally) values in place. Key-value and key-only sort is selected through the configuration of the plan, using the options CUDPP_OPTION_KEYS_ONLY and CUDPP_OPTION_KEY_VALUE_PAIRS.</p>
<p>Supported key types are CUDPP_FLOAT and CUDPP_UINT. Values can be any 32-bit type (internally, values are treated only as a payload and cast to unsigned int).</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000011">Todo:</a></b></dt><dd>Determine if we need to provide an "out of place" sort interface.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">planHandle</td><td>handle to CUDPPSortPlan </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_keys</td><td>keys by which key-value pairs will be sorted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_values</td><td>values to be sorted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keyBits</td><td>the number of least significant bits in each element of d_keys to sort by </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>number of elements in d_keys and d_values</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__public_interface.html#ga31fd56135f9c8f73da79af83a958f27c" title="Create a CUDPP plan.">cudppPlan</a>, <a class="el" href="struct_c_u_d_p_p_configuration.html" title="Configuration struct used to specify algorithm, datatype, operator, and options when creating a plan ...">CUDPPConfiguration</a>, <a class="el" href="cudpp_8h.html#a6499e5c26f56db82f520367ae853462f" title="Algorithms supported by CUDPP. Used to create appropriate plans using cudppPlan.">CUDPPAlgorithm</a> </dd></dl>

<p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000012">Todo:</a></b></dt><dd>Return more specific errors. </dd></dl>
</p>

</div>
</div>
<a class="anchor" id="gaeedaa3a7ec8bbd6770c6fbce3c4276c5"></a><!-- doxytag: member="cudpp.cpp::cudppSparseMatrixVectorMultiply" ref="gaeedaa3a7ec8bbd6770c6fbce3c4276c5" args="(const CUDPPHandle sparseMatrixHandle, void *d_y, const void *d_x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppSparseMatrixVectorMultiply </td>
          <td>(</td>
          <td class="paramtype">const CUDPPHandle&#160;</td>
          <td class="paramname"><em>sparseMatrixHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>d_x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform matrix-vector multiply y = A*x for arbitrary sparse matrix A and vector x. </p>
<p>Given a matrix object handle (which has been initialized using <a class="el" href="group__public_interface.html#gabc6c2587fe06dadd93fb1d69ba836d84" title="Create a CUDPP Sparse Matrix Object.">cudppSparseMatrix()</a>), This function multiplies the input vector <em>d_x</em> by the matrix referred to by <em>sparseMatrixHandle</em>, returning the result in <em>d_y</em>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sparseMatrixHandle</td><td>Handle to a sparse matrix object created with <a class="el" href="group__public_interface.html#gabc6c2587fe06dadd93fb1d69ba836d84" title="Create a CUDPP Sparse Matrix Object.">cudppSparseMatrix()</a> </td></tr>
    <tr><td class="paramname">d_y</td><td>The output vector, y </td></tr>
    <tr><td class="paramname">d_x</td><td>The input vector, x</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__public_interface.html#gabc6c2587fe06dadd93fb1d69ba836d84" title="Create a CUDPP Sparse Matrix Object.">cudppSparseMatrix</a>, <a class="el" href="group__public_interface.html#gae0644c758120abaef0e2bb396f57cefb" title="Destroy a CUDPP Sparse Matrix Object.">cudppDestroySparseMatrix</a> </dd></dl>

<p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000013">Todo:</a></b></dt><dd>Return more specific errors. </dd></dl>
</p>

</div>
</div>
<a class="anchor" id="gac27c987891faceedf79598f744212c67"></a><!-- doxytag: member="cudpp.cpp::cudppRand" ref="gac27c987891faceedf79598f744212c67" args="(const CUDPPHandle planHandle, void *d_out, size_t numElements)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppRand </td>
          <td>(</td>
          <td class="paramtype">const CUDPPHandle&#160;</td>
          <td class="paramname"><em>planHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rand puts <em>numElements</em> random 32-bit elements into <em>d_out</em>. </p>
<p>Outputs <em>numElements</em> random values to <em>d_out</em>. <em>d_out</em> must be of type unsigned int, allocated in device memory.</p>
<p>The algorithm used for the random number generation is stored in <em>planHandle</em>. Depending on the specification of the pseudo random number generator(PRNG), the generator may have one or more seeds. To set the seed, use <a class="el" href="group__public_interface.html#ga9120af9942d2553d2f376ede0f7079dd" title="Sets the seed used for rand.">cudppRandSeed()</a>.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000014">Todo:</a></b></dt><dd>Currently only MD5 PRNG is supported. We may provide more rand routines in the future.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">planHandle</td><td>Handle to plan for rand </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>number of elements in d_out. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_out</td><td>output of rand, in GPU memory. Should be an array of unsigned integers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__public_interface.html#ga31fd56135f9c8f73da79af83a958f27c" title="Create a CUDPP plan.">cudppPlan</a>, <a class="el" href="struct_c_u_d_p_p_configuration.html" title="Configuration struct used to specify algorithm, datatype, operator, and options when creating a plan ...">CUDPPConfiguration</a>, <a class="el" href="cudpp_8h.html#a6499e5c26f56db82f520367ae853462f" title="Algorithms supported by CUDPP. Used to create appropriate plans using cudppPlan.">CUDPPAlgorithm</a> </dd></dl>

<p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000015">Todo:</a></b></dt><dd>Return more specific errors </dd></dl>
</p>

</div>
</div>
<a class="anchor" id="ga9120af9942d2553d2f376ede0f7079dd"></a><!-- doxytag: member="cudpp.cpp::cudppRandSeed" ref="ga9120af9942d2553d2f376ede0f7079dd" args="(const CUDPPHandle planHandle, unsigned int seed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppRandSeed </td>
          <td>(</td>
          <td class="paramtype">const CUDPPHandle&#160;</td>
          <td class="paramname"><em>planHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the seed used for rand. </p>
<p>The seed is crucial to any random number generator as it allows a sequence of random numbers to be replicated. Since there may be multiple different rand algorithms in CUDPP, cudppRandSeed uses <em>planHandle</em> to determine which seed to set. Each rand algorithm has its own unique set of seeds depending on what the algorithm needs.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">planHandle</td><td>the handle to the plan which specifies which rand seed to set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seed</td><td>the value which the internal cudpp seed will be set to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9156a26943f99d0fff44d218129631b4"></a><!-- doxytag: member="cudpp_manager.cpp::cudppCreate" ref="ga9156a26943f99d0fff44d218129631b4" args="(CUDPPHandle *theCudpp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppCreate </td>
          <td>(</td>
          <td class="paramtype">CUDPPHandle *&#160;</td>
          <td class="paramname"><em>theCudpp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an instance of the CUDPP library, and returns a handle. </p>
<p><a class="el" href="group__public_interface.html#ga9156a26943f99d0fff44d218129631b4" title="Creates an instance of the CUDPP library, and returns a handle.">cudppCreate()</a> must be called before any other CUDPP function. In a multi-GPU application that uses multiple CUDA context, <a class="el" href="group__public_interface.html#ga9156a26943f99d0fff44d218129631b4" title="Creates an instance of the CUDPP library, and returns a handle.">cudppCreate()</a> must be called once for each CUDA context. Each call returns a different handle, because each CUDA context (and the host thread that owns it) must use a separate instance of the CUDPP library.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">theCudpp</td><td>a pointer to the CUDPPHandle for the created CUDPP instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8b98b05d585860ec4fcc44472244d01b"></a><!-- doxytag: member="cudpp_manager.cpp::cudppDestroy" ref="ga8b98b05d585860ec4fcc44472244d01b" args="(CUDPPHandle theCudpp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppDestroy </td>
          <td>(</td>
          <td class="paramtype">CUDPPHandle&#160;</td>
          <td class="paramname"><em>theCudpp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroys an instance of the CUDPP library given its handle. </p>
<p><a class="el" href="group__public_interface.html#ga8b98b05d585860ec4fcc44472244d01b" title="Destroys an instance of the CUDPP library given its handle.">cudppDestroy()</a> should be called once for each handle created using <a class="el" href="group__public_interface.html#ga9156a26943f99d0fff44d218129631b4" title="Creates an instance of the CUDPP library, and returns a handle.">cudppCreate()</a>, to ensure proper resource cleanup of all library instances.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theCudpp</td><td>the handle to the CUDPP instance to destroy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga31fd56135f9c8f73da79af83a958f27c"></a><!-- doxytag: member="cudpp_plan.cpp::cudppPlan" ref="ga31fd56135f9c8f73da79af83a958f27c" args="(const CUDPPHandle cudppHandle, CUDPPHandle *planHandle, CUDPPConfiguration config, size_t numElements, size_t numRows, size_t rowPitch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppPlan </td>
          <td>(</td>
          <td class="paramtype">const CUDPPHandle&#160;</td>
          <td class="paramname"><em>cudppHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CUDPPHandle *&#160;</td>
          <td class="paramname"><em>planHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_u_d_p_p_configuration.html">CUDPPConfiguration</a>&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rowPitch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a CUDPP plan. </p>
<p>A plan is a data structure containing state and intermediate storage space that CUDPP uses to execute algorithms on data. A plan is created by passing to <a class="el" href="group__public_interface.html#ga31fd56135f9c8f73da79af83a958f27c" title="Create a CUDPP plan.">cudppPlan()</a> a <a class="el" href="struct_c_u_d_p_p_configuration.html" title="Configuration struct used to specify algorithm, datatype, operator, and options when creating a plan ...">CUDPPConfiguration</a> that specifies the algorithm, operator, datatype, and options. The size of the data must also be passed to <a class="el" href="group__public_interface.html#ga31fd56135f9c8f73da79af83a958f27c" title="Create a CUDPP plan.">cudppPlan()</a>, in the <em>numElements</em>, <em>numRows</em>, and <em>rowPitch</em> arguments. These sizes are used to allocate internal storage space at the time the plan is created. The CUDPP planner may use the sizes, options, and information about the present hardware to choose optimal settings.</p>
<p>Note that <em>numElements</em> is the maximum size of the array to be processed with this plan. That means that a plan may be re-used to process (for example, to sort or scan) smaller arrays.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">planHandle</td><td>A pointer to an opaque handle to the internal plan </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cudppHandle</td><td>A handle to an instance of the CUDPP library used for resource management </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>The configuration struct specifying algorithm and options </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>The maximum number of elements to be processed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numRows</td><td>The number of rows (for 2D operations) to be processed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rowPitch</td><td>The pitch of the rows of input data, in elements </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4015898886e140ad95f320ab4c07db2c"></a><!-- doxytag: member="cudpp_plan.cpp::cudppDestroyPlan" ref="ga4015898886e140ad95f320ab4c07db2c" args="(CUDPPHandle planHandle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppDestroyPlan </td>
          <td>(</td>
          <td class="paramtype">CUDPPHandle&#160;</td>
          <td class="paramname"><em>planHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroy a CUDPP Plan. </p>
<p>Deletes the plan referred to by <em>planHandle</em> and all associated internal storage.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">planHandle</td><td>The CUDPPHandle to the plan to be destroyed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabc6c2587fe06dadd93fb1d69ba836d84"></a><!-- doxytag: member="cudpp_plan.cpp::cudppSparseMatrix" ref="gabc6c2587fe06dadd93fb1d69ba836d84" args="(const CUDPPHandle cudppHandle, CUDPPHandle *sparseMatrixHandle, CUDPPConfiguration config, size_t numNonZeroElements, size_t numRows, const void *A, const unsigned int *h_rowIndices, const unsigned int *h_indices)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppSparseMatrix </td>
          <td>(</td>
          <td class="paramtype">const CUDPPHandle&#160;</td>
          <td class="paramname"><em>cudppHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CUDPPHandle *&#160;</td>
          <td class="paramname"><em>sparseMatrixHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_u_d_p_p_configuration.html">CUDPPConfiguration</a>&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numNonZeroElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>h_rowIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>h_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a CUDPP Sparse Matrix Object. </p>
<p>The sparse matrix plan is a data structure containing state and intermediate storage space that CUDPP uses to perform sparse matrix dense vector multiply. This plan is created by passing to CUDPPSparseMatrixVectorMultiplyPlan() a <a class="el" href="struct_c_u_d_p_p_configuration.html" title="Configuration struct used to specify algorithm, datatype, operator, and options when creating a plan ...">CUDPPConfiguration</a> that specifies the algorithm (sprarse matrix-dense vector multiply) and datatype, along with the sparse matrix itself in CSR format. The number of non-zero elements in the sparse matrix must also be passed as <em>numNonZeroElements</em>. This is used to allocate internal storage space at the time the sparse matrix plan is created.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">sparseMatrixHandle</td><td>A pointer to an opaque handle to the sparse matrix object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cudppHandle</td><td>A handle to an instance of the CUDPP library used for resource management </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>The configuration struct specifying algorithm and options </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numNonZeroElements</td><td>The number of non zero elements in the sparse matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numRows</td><td>This is the number of rows in y, x and A for y = A * x </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>The matrix data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">h_rowIndices</td><td>An array containing the index of the start of each row in <em>A</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">h_indices</td><td>An array containing the index of each nonzero element in <em>A</em> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae0644c758120abaef0e2bb396f57cefb"></a><!-- doxytag: member="cudpp_plan.cpp::cudppDestroySparseMatrix" ref="gae0644c758120abaef0e2bb396f57cefb" args="(CUDPPHandle sparseMatrixHandle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CUDPP_DLL <a class="el" href="cudpp_8h.html#a4a73ab815831334b5a7649e538ac1d0a">CUDPPResult</a> cudppDestroySparseMatrix </td>
          <td>(</td>
          <td class="paramtype">CUDPPHandle&#160;</td>
          <td class="paramname"><em>sparseMatrixHandle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroy a CUDPP Sparse Matrix Object. </p>
<p>Deletes the sparse matrix data and plan referred to by <em>sparseMatrixHandle</em> and all associated internal storage.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sparseMatrixHandle</td><td>The CUDPPHandle to the matrix object to be destroyed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Wed Feb 16 2011 16:10:07 for CUDPP by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
